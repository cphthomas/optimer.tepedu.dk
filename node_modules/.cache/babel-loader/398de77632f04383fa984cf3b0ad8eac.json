{"ast":null,"code":"/*global describe*/\n\n/*global require*/\n\n/*global module*/\n\n/*global it*/\n\n/*global console*/\n\n/*global process*/\nvar Solution = require(\"./Solution.js\");\n\nvar MilpSolution = require(\"./MilpSolution.js\");\n/*************************************************************\r\n * Class: Tableau\r\n * Description: Simplex tableau, holding a the tableau matrix\r\n *              and all the information necessary to perform\r\n *              the simplex algorithm\r\n * Agruments:\r\n *        precision: If we're solving a MILP, how tight\r\n *                   do we want to define an integer, given\r\n *                   that 20.000000000000001 is not an integer.\r\n *                   (defaults to 1e-8)\r\n **************************************************************/\n\n\nfunction Tableau(precision) {\n  this.model = null;\n  this.matrix = null;\n  this.width = 0;\n  this.height = 0;\n  this.costRowIndex = 0;\n  this.rhsColumn = 0;\n  this.variablesPerIndex = [];\n  this.unrestrictedVars = null; // Solution attributes\n\n  this.feasible = true; // until proven guilty\n\n  this.evaluation = 0;\n  this.simplexIters = 0;\n  this.varIndexByRow = null;\n  this.varIndexByCol = null;\n  this.rowByVarIndex = null;\n  this.colByVarIndex = null;\n  this.precision = precision || 1e-8;\n  this.optionalObjectives = [];\n  this.objectivesByPriority = {};\n  this.savedState = null;\n  this.availableIndexes = [];\n  this.lastElementIndex = 0;\n  this.variables = null;\n  this.nVars = 0;\n  this.bounded = true;\n  this.unboundedVarIndex = null;\n  this.branchAndCutIterations = 0;\n}\n\nmodule.exports = Tableau;\n\nTableau.prototype.solve = function () {\n  if (this.model.getNumberOfIntegerVariables() > 0) {\n    this.branchAndCut();\n  } else {\n    this.simplex();\n  }\n\n  this.updateVariableValues();\n  return this.getSolution();\n};\n\nfunction OptionalObjective(priority, nColumns) {\n  this.priority = priority;\n  this.reducedCosts = new Array(nColumns);\n\n  for (var c = 0; c < nColumns; c += 1) {\n    this.reducedCosts[c] = 0;\n  }\n}\n\nOptionalObjective.prototype.copy = function () {\n  var copy = new OptionalObjective(this.priority, this.reducedCosts.length);\n  copy.reducedCosts = this.reducedCosts.slice();\n  return copy;\n};\n\nTableau.prototype.setOptionalObjective = function (priority, column, cost) {\n  var objectiveForPriority = this.objectivesByPriority[priority];\n\n  if (objectiveForPriority === undefined) {\n    var nColumns = Math.max(this.width, column + 1);\n    objectiveForPriority = new OptionalObjective(priority, nColumns);\n    this.objectivesByPriority[priority] = objectiveForPriority;\n    this.optionalObjectives.push(objectiveForPriority);\n    this.optionalObjectives.sort(function (a, b) {\n      return a.priority - b.priority;\n    });\n  }\n\n  objectiveForPriority.reducedCosts[column] = cost;\n}; //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nTableau.prototype.initialize = function (width, height, variables, unrestrictedVars) {\n  this.variables = variables;\n  this.unrestrictedVars = unrestrictedVars;\n  this.width = width;\n  this.height = height; // console.time(\"tableau_build\");\n  // BUILD AN EMPTY ARRAY OF THAT WIDTH\n\n  var tmpRow = new Array(width);\n\n  for (var i = 0; i < width; i++) {\n    tmpRow[i] = 0;\n  } // BUILD AN EMPTY TABLEAU\n\n\n  this.matrix = new Array(height);\n\n  for (var j = 0; j < height; j++) {\n    this.matrix[j] = tmpRow.slice();\n  } //\n  // TODO: Benchmark This\n  //this.matrix = new Array(height).fill(0).map(() => new Array(width).fill(0));\n  // console.timeEnd(\"tableau_build\");\n  // console.log(\"height\",height);\n  // console.log(\"width\",width);\n  // console.log(\"------\");\n  // console.log(\"\");\n\n\n  this.varIndexByRow = new Array(this.height);\n  this.varIndexByCol = new Array(this.width);\n  this.varIndexByRow[0] = -1;\n  this.varIndexByCol[0] = -1;\n  this.nVars = width + height - 2;\n  this.rowByVarIndex = new Array(this.nVars);\n  this.colByVarIndex = new Array(this.nVars);\n  this.lastElementIndex = this.nVars;\n};\n\nTableau.prototype._resetMatrix = function () {\n  var variables = this.model.variables;\n  var constraints = this.model.constraints;\n  var nVars = variables.length;\n  var nConstraints = constraints.length;\n  var v, varIndex;\n  var costRow = this.matrix[0];\n  var coeff = this.model.isMinimization === true ? -1 : 1;\n\n  for (v = 0; v < nVars; v += 1) {\n    var variable = variables[v];\n    var priority = variable.priority;\n    var cost = coeff * variable.cost;\n\n    if (priority === 0) {\n      costRow[v + 1] = cost;\n    } else {\n      this.setOptionalObjective(priority, v + 1, cost);\n    }\n\n    varIndex = variables[v].index;\n    this.rowByVarIndex[varIndex] = -1;\n    this.colByVarIndex[varIndex] = v + 1;\n    this.varIndexByCol[v + 1] = varIndex;\n  }\n\n  var rowIndex = 1;\n\n  for (var c = 0; c < nConstraints; c += 1) {\n    var constraint = constraints[c];\n    var constraintIndex = constraint.index;\n    this.rowByVarIndex[constraintIndex] = rowIndex;\n    this.colByVarIndex[constraintIndex] = -1;\n    this.varIndexByRow[rowIndex] = constraintIndex;\n    var t, term, column;\n    var terms = constraint.terms;\n    var nTerms = terms.length;\n    var row = this.matrix[rowIndex++];\n\n    if (constraint.isUpperBound) {\n      for (t = 0; t < nTerms; t += 1) {\n        term = terms[t];\n        column = this.colByVarIndex[term.variable.index];\n        row[column] = term.coefficient;\n      }\n\n      row[0] = constraint.rhs;\n    } else {\n      for (t = 0; t < nTerms; t += 1) {\n        term = terms[t];\n        column = this.colByVarIndex[term.variable.index];\n        row[column] = -term.coefficient;\n      }\n\n      row[0] = -constraint.rhs;\n    }\n  }\n}; //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nTableau.prototype.setModel = function (model) {\n  this.model = model;\n  var width = model.nVariables + 1;\n  var height = model.nConstraints + 1;\n  this.initialize(width, height, model.variables, model.unrestrictedVariables);\n\n  this._resetMatrix();\n\n  return this;\n};\n\nTableau.prototype.getNewElementIndex = function () {\n  if (this.availableIndexes.length > 0) {\n    return this.availableIndexes.pop();\n  }\n\n  var index = this.lastElementIndex;\n  this.lastElementIndex += 1;\n  return index;\n};\n\nTableau.prototype.density = function () {\n  var density = 0;\n  var matrix = this.matrix;\n\n  for (var r = 0; r < this.height; r++) {\n    var row = matrix[r];\n\n    for (var c = 0; c < this.width; c++) {\n      if (row[c] !== 0) {\n        density += 1;\n      }\n    }\n  }\n\n  return density / (this.height * this.width);\n}; //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nTableau.prototype.setEvaluation = function () {\n  // Rounding objective value\n  var roundingCoeff = Math.round(1 / this.precision);\n  var evaluation = this.matrix[this.costRowIndex][this.rhsColumn];\n  var roundedEvaluation = Math.round((Number.EPSILON + evaluation) * roundingCoeff) / roundingCoeff;\n  this.evaluation = roundedEvaluation;\n\n  if (this.simplexIters === 0) {\n    this.bestPossibleEval = roundedEvaluation;\n  }\n}; //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nTableau.prototype.getSolution = function () {\n  var evaluation = this.model.isMinimization === true ? this.evaluation : -this.evaluation;\n\n  if (this.model.getNumberOfIntegerVariables() > 0) {\n    return new MilpSolution(this, evaluation, this.feasible, this.bounded, this.branchAndCutIterations);\n  } else {\n    return new Solution(this, evaluation, this.feasible, this.bounded);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}