{"ast":null,"code":"/*global describe*/\n\n/*global require*/\n\n/*global module*/\n\n/*global it*/\n\n/*global console*/\n\n/*global process*/\nvar Tableau = require(\"./Tableau.js\"); //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nfunction Cut(type, varIndex, value) {\n  this.type = type;\n  this.varIndex = varIndex;\n  this.value = value;\n} //-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\n\nfunction Branch(relaxedEvaluation, cuts) {\n  this.relaxedEvaluation = relaxedEvaluation;\n  this.cuts = cuts;\n} //-------------------------------------------------------------------\n// Branch sorting strategies\n//-------------------------------------------------------------------\n\n\nfunction sortByEvaluation(a, b) {\n  return b.relaxedEvaluation - a.relaxedEvaluation;\n} //-------------------------------------------------------------------\n// Applying cuts on a tableau and resolving\n//-------------------------------------------------------------------\n\n\nTableau.prototype.applyCuts = function (branchingCuts) {\n  // Restoring initial solution\n  this.restore();\n  this.addCutConstraints(branchingCuts);\n  this.simplex(); // Adding MIR cuts\n\n  if (this.model.useMIRCuts) {\n    var fractionalVolumeImproved = true;\n\n    while (fractionalVolumeImproved) {\n      var fractionalVolumeBefore = this.computeFractionalVolume(true);\n      this.applyMIRCuts();\n      this.simplex();\n      var fractionalVolumeAfter = this.computeFractionalVolume(true); // If the new fractional volume is bigger than 90% of the previous one\n      // we assume there is no improvement from the MIR cuts\n\n      if (fractionalVolumeAfter >= 0.9 * fractionalVolumeBefore) {\n        fractionalVolumeImproved = false;\n      }\n    }\n  }\n}; //-------------------------------------------------------------------\n// Function: MILP\n// Detail: Main function, my attempt at a mixed integer linear programming\n//         solver\n//-------------------------------------------------------------------\n\n\nTableau.prototype.branchAndCut = function () {\n  var branches = [];\n  var iterations = 0;\n  var tolerance = this.model.tolerance;\n  var toleranceFlag = true;\n  var terminalTime = 1e99; //\n  // Set Start Time on model...\n  // Let's build out a way to *gracefully* quit\n  // after {{time}} milliseconds\n  //\n  // 1.) Check to see if there's a timeout on the model\n  //\n\n  if (this.model.timeout) {\n    // 2.) Hooray! There is!\n    //     Calculate the final date\n    //\n    terminalTime = Date.now() + this.model.timeout;\n  } // This is the default result\n  // If nothing is both *integral* and *feasible*\n\n\n  var bestEvaluation = Infinity;\n  var bestBranch = null;\n  var bestOptionalObjectivesEvaluations = [];\n\n  for (var oInit = 0; oInit < this.optionalObjectives.length; oInit += 1) {\n    bestOptionalObjectivesEvaluations.push(Infinity);\n  } // And here...we...go!\n  // 1.) Load a model into the queue\n\n\n  var branch = new Branch(-Infinity, []);\n  var acceptableThreshold;\n  branches.push(branch); // If all branches have been exhausted terminate the loop\n\n  while (branches.length > 0 && toleranceFlag === true && Date.now() < terminalTime) {\n    if (this.model.isMinimization) {\n      acceptableThreshold = this.bestPossibleEval * (1 + tolerance);\n    } else {\n      acceptableThreshold = this.bestPossibleEval * (1 - tolerance);\n    } // Abort while loop if termination tolerance is both specified and condition is met\n\n\n    if (tolerance > 0) {\n      if (bestEvaluation < acceptableThreshold) {\n        toleranceFlag = false;\n      }\n    } // Get a model from the queue\n\n\n    branch = branches.pop();\n\n    if (branch.relaxedEvaluation > bestEvaluation) {\n      continue;\n    } // Solving from initial relaxed solution\n    // with additional cut constraints\n    // Adding cut constraints\n\n\n    var cuts = branch.cuts;\n    this.applyCuts(cuts);\n    iterations++;\n\n    if (this.feasible === false) {\n      continue;\n    }\n\n    var evaluation = this.evaluation;\n\n    if (evaluation > bestEvaluation) {\n      // This branch does not contain the optimal solution\n      continue;\n    } // To deal with the optional objectives\n\n\n    if (evaluation === bestEvaluation) {\n      var isCurrentEvaluationWorse = true;\n\n      for (var o = 0; o < this.optionalObjectives.length; o += 1) {\n        if (this.optionalObjectives[o].reducedCosts[0] > bestOptionalObjectivesEvaluations[o]) {\n          break;\n        } else if (this.optionalObjectives[o].reducedCosts[0] < bestOptionalObjectivesEvaluations[o]) {\n          isCurrentEvaluationWorse = false;\n          break;\n        }\n      }\n\n      if (isCurrentEvaluationWorse) {\n        continue;\n      }\n    } // Is the model both integral and feasible?\n\n\n    if (this.isIntegral() === true) {\n      //\n      // Store the fact that we are integral\n      //\n      this.__isIntegral = true;\n\n      if (iterations === 1) {\n        this.branchAndCutIterations = iterations;\n        return;\n      } // Store the solution as the bestSolution\n\n\n      bestBranch = branch;\n      bestEvaluation = evaluation;\n\n      for (var oCopy = 0; oCopy < this.optionalObjectives.length; oCopy += 1) {\n        bestOptionalObjectivesEvaluations[oCopy] = this.optionalObjectives[oCopy].reducedCosts[0];\n      }\n    } else {\n      if (iterations === 1) {\n        // Saving the first iteration\n        // TODO: implement a better strategy for saving the tableau?\n        this.save();\n      } // If the solution is\n      //  a. Feasible\n      //  b. Better than the current solution\n      //  c. but *NOT* integral\n      // So the solution isn't integral? How do we solve this.\n      // We create 2 new models, that are mirror images of the prior\n      // model, with 1 exception.\n      // Say we're trying to solve some stupid problem requiring you get\n      // animals for your daughter's kindergarten petting zoo party\n      // and you have to choose how many ducks, goats, and lambs to get.\n      // Say that the optimal solution to this problem if we didn't have\n      // to make it integral was {duck: 8, lambs: 3.5}\n      //\n      // To keep from traumatizing your daughter and the other children\n      // you're going to want to have whole animals\n      // What we would do is find the most fractional variable (lambs)\n      // and create new models from the old models, but with a new constraint\n      // on apples. The constraints on the low model would look like:\n      // constraints: {...\n      //   lamb: {max: 3}\n      //   ...\n      // }\n      //\n      // while the constraints on the high model would look like:\n      //\n      // constraints: {...\n      //   lamb: {min: 4}\n      //   ...\n      // }\n      // If neither of these models is feasible because of this constraint,\n      // the model is not integral at this point, and fails.\n      // Find out where we want to split the solution\n\n\n      var variable = this.getMostFractionalVar();\n      var varIndex = variable.index;\n      var cutsHigh = [];\n      var cutsLow = [];\n      var nCuts = cuts.length;\n\n      for (var c = 0; c < nCuts; c += 1) {\n        var cut = cuts[c];\n\n        if (cut.varIndex === varIndex) {\n          if (cut.type === \"min\") {\n            cutsLow.push(cut);\n          } else {\n            cutsHigh.push(cut);\n          }\n        } else {\n          cutsHigh.push(cut);\n          cutsLow.push(cut);\n        }\n      }\n\n      var min = Math.ceil(variable.value);\n      var max = Math.floor(variable.value);\n      var cutHigh = new Cut(\"min\", varIndex, min);\n      cutsHigh.push(cutHigh);\n      var cutLow = new Cut(\"max\", varIndex, max);\n      cutsLow.push(cutLow);\n      branches.push(new Branch(evaluation, cutsHigh));\n      branches.push(new Branch(evaluation, cutsLow)); // Sorting branches\n      // Branches with the most promising lower bounds\n      // will be picked first\n\n      branches.sort(sortByEvaluation);\n    }\n  } // Adding cut constraints for the optimal solution\n\n\n  if (bestBranch !== null) {\n    // The model is feasible\n    this.applyCuts(bestBranch.cuts);\n  }\n\n  this.branchAndCutIterations = iterations;\n};","map":null,"metadata":{},"sourceType":"script"}