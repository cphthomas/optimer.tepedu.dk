{"ast":null,"code":"/*global describe*/\n\n/*global require*/\n\n/*global module*/\n\n/*global it*/\n\n/*global console*/\n\n/*global process*/\n\n/***************************************************************\r\n * Method: polyopt\r\n * Scope: private\r\n * Agruments:\r\n *        model: The model we want solver to operate on.\r\n                 Because we're in here, we're assuming that\r\n                 we're solving a multi-objective optimization\r\n                 problem. Poly-Optimization. polyopt.\r\n                   This model has to be formed a little differently\r\n                 because it has multiple objective functions.\r\n                 Normally, a model has 2 attributes: opType (string,\r\n                 \"max\" or \"min\"), and optimize (string, whatever\r\n                 attribute we're optimizing.\r\n                   Now, there is no opType attribute on the model,\r\n                 and optimize is an object of attributes to be\r\n                 optimized, and how they're to be optimized.\r\n                 For example:\r\n                   ...\r\n                 \"optimize\": {\r\n                    \"pancakes\": \"max\",\r\n                    \"cost\": \"minimize\"\r\n                 }\r\n                 ...\r\n     **************************************************************/\nmodule.exports = function (solver, model) {\n  // I have no idea if this is actually works, or what,\n  // but here is my algorithm to solve linear programs\n  // with multiple objective functions\n  // 1. Optimize for each constraint\n  // 2. The results for each solution is a vector\n  //    representing a vertex on the polytope we're creating\n  // 3. The results for all solutions describes the shape\n  //    of the polytope (would be nice to have the equation\n  //    representing this)\n  // 4. Find the mid-point between all vertices by doing the\n  //    following (a_1 + a_2 ... a_n) / n;\n  var objectives = model.optimize,\n      new_constraints = JSON.parse(JSON.stringify(model.optimize)),\n      keys = Object.keys(model.optimize),\n      tmp,\n      counter = 0,\n      vectors = {},\n      vector_key = \"\",\n      obj = {},\n      pareto = [],\n      i,\n      j,\n      x,\n      y,\n      z; // Delete the optimize object from the model\n\n  delete model.optimize; // Iterate and Clear\n\n  for (i = 0; i < keys.length; i++) {\n    // Clean up the new_constraints\n    new_constraints[keys[i]] = 0;\n  } // Solve and add\n\n\n  for (i = 0; i < keys.length; i++) {\n    // Prep the model\n    model.optimize = keys[i];\n    model.opType = objectives[keys[i]]; // solve the model\n\n    tmp = solver.Solve(model, undefined, undefined, true); // Only the variables make it into the solution;\n    // not the attributes.\n    //\n    // Because of this, we have to add the attributes\n    // back onto the solution so we can do math with\n    // them later...\n    // Loop over the keys\n\n    for (y in keys) {\n      // We're only worried about attributes, not variables\n      if (!model.variables[keys[y]]) {\n        // Create space for the attribute in the tmp object\n        tmp[keys[y]] = tmp[keys[y]] ? tmp[keys[y]] : 0; // Go over each of the variables\n\n        for (x in model.variables) {\n          // Does the variable exist in tmp *and* does attribute exist in this model?\n          if (model.variables[x][keys[y]] && tmp[x]) {\n            // Add it to tmp\n            tmp[keys[y]] += tmp[x] * model.variables[x][keys[y]];\n          }\n        }\n      }\n    } // clear our key\n\n\n    vector_key = \"base\"; // this makes sure that if we get\n    // the same vector more than once,\n    // we only count it once when finding\n    // the midpoint\n\n    for (j = 0; j < keys.length; j++) {\n      if (tmp[keys[j]]) {\n        vector_key += \"-\" + (tmp[keys[j]] * 1000 | 0) / 1000;\n      } else {\n        vector_key += \"-0\";\n      }\n    } // Check here to ensure it doesn't exist\n\n\n    if (!vectors[vector_key]) {\n      // Add the vector-key in\n      vectors[vector_key] = 1;\n      counter++; // Iterate over the keys\n      // and update our new constraints\n\n      for (j = 0; j < keys.length; j++) {\n        if (tmp[keys[j]]) {\n          new_constraints[keys[j]] += tmp[keys[j]];\n        }\n      } // Push the solution into the paretos\n      // array after cleaning it of some\n      // excess data markers\n\n\n      delete tmp.feasible;\n      delete tmp.result;\n      pareto.push(tmp);\n    }\n  } // Trying to find the mid-point\n  // divide each constraint by the\n  // number of constraints\n  // *midpoint formula*\n  // (x1 + x2 + x3) / 3\n\n\n  for (i = 0; i < keys.length; i++) {\n    model.constraints[keys[i]] = {\n      \"equal\": new_constraints[keys[i]] / counter\n    };\n  } // Give the model a fake thing to optimize on\n\n\n  model.optimize = \"cheater-\" + Math.random();\n  model.opType = \"max\"; // And add the fake attribute to the variables\n  // in the model\n\n  for (i in model.variables) {\n    model.variables[i].cheater = 1;\n  } // Build out the object with all attributes\n\n\n  for (i in pareto) {\n    for (x in pareto[i]) {\n      obj[x] = obj[x] || {\n        min: 1e99,\n        max: -1e99\n      };\n    }\n  } // Give each pareto a full attribute list\n  // while getting the max and min values\n  // for each attribute\n\n\n  for (i in obj) {\n    for (x in pareto) {\n      if (pareto[x][i]) {\n        if (pareto[x][i] > obj[i].max) {\n          obj[i].max = pareto[x][i];\n        }\n\n        if (pareto[x][i] < obj[i].min) {\n          obj[i].min = pareto[x][i];\n        }\n      } else {\n        pareto[x][i] = 0;\n        obj[i].min = 0;\n      }\n    }\n  } // Solve the model for the midpoints\n\n\n  tmp = solver.Solve(model, undefined, undefined, true);\n  return {\n    midpoint: tmp,\n    vertices: pareto,\n    ranges: obj\n  };\n};","map":null,"metadata":{},"sourceType":"script"}