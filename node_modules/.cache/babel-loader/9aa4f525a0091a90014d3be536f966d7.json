{"ast":null,"code":"/*\n Highcharts JS v8.1.2 (2020-06-16)\n\n 3D features for Highcharts JS\n\n License: www.highcharts.com/license\n*/\n(function (b) {\n  \"object\" === typeof module && module.exports ? (b[\"default\"] = b, module.exports = b) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-3d\", [\"highcharts\"], function (F) {\n    b(F);\n    b.Highcharts = F;\n    return b;\n  }) : b(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (b) {\n  function F(b, t, l, d) {\n    b.hasOwnProperty(t) || (b[t] = d.apply(null, l));\n  }\n\n  b = b ? b._modules : {};\n  F(b, \"parts-3d/Math.js\", [b[\"parts/Globals.js\"], b[\"parts/Utilities.js\"]], function (b, t) {\n    var l = t.pick,\n        d = b.deg2rad;\n\n    b.perspective3D = function (d, n, q) {\n      n = 0 < q && q < Number.POSITIVE_INFINITY ? q / (d.z + n.z + q) : 1;\n      return {\n        x: d.x * n,\n        y: d.y * n\n      };\n    };\n\n    b.perspective = function (w, n, q, D) {\n      var m = n.options.chart.options3d,\n          u = l(D, q ? n.inverted : !1),\n          g = {\n        x: n.plotWidth / 2,\n        y: n.plotHeight / 2,\n        z: m.depth / 2,\n        vd: l(m.depth, 1) * l(m.viewDistance, 0)\n      },\n          p = n.scale3d || 1;\n      D = d * m.beta * (u ? -1 : 1);\n      m = d * m.alpha * (u ? -1 : 1);\n      var t = Math.cos(m),\n          y = Math.cos(-D),\n          a = Math.sin(m),\n          k = Math.sin(-D);\n      q || (g.x += n.plotLeft, g.y += n.plotTop);\n      return w.map(function (x) {\n        var c = (u ? x.y : x.x) - g.x;\n        var h = (u ? x.x : x.y) - g.y;\n        x = (x.z || 0) - g.z;\n        c = {\n          x: y * c - k * x,\n          y: -a * k * c + t * h - y * a * x,\n          z: t * k * c + a * h + t * y * x\n        };\n        h = b.perspective3D(c, g, g.vd);\n        h.x = h.x * p + g.x;\n        h.y = h.y * p + g.y;\n        h.z = c.z * p + g.z;\n        return {\n          x: u ? h.y : h.x,\n          y: u ? h.x : h.y,\n          z: h.z\n        };\n      });\n    };\n\n    b.pointCameraDistance = function (d, n) {\n      var q = n.options.chart.options3d,\n          b = n.plotWidth / 2;\n      n = n.plotHeight / 2;\n      q = l(q.depth, 1) * l(q.viewDistance, 0) + q.depth;\n      return Math.sqrt(Math.pow(b - l(d.plotX, d.x), 2) + Math.pow(n - l(d.plotY, d.y), 2) + Math.pow(q - l(d.plotZ, d.z), 2));\n    };\n\n    b.shapeArea = function (d) {\n      var n = 0,\n          q;\n\n      for (q = 0; q < d.length; q++) {\n        var b = (q + 1) % d.length;\n        n += d[q].x * d[b].y - d[b].x * d[q].y;\n      }\n\n      return n / 2;\n    };\n\n    b.shapeArea3d = function (d, n, q) {\n      return b.shapeArea(b.perspective(d, n, q));\n    };\n  });\n  F(b, \"parts-3d/SVGRenderer.js\", [b[\"parts/Color.js\"], b[\"parts/Globals.js\"], b[\"parts/SVGElement.js\"], b[\"parts/SVGRenderer.js\"], b[\"parts/Utilities.js\"]], function (b, t, l, d, w) {\n    function n(a, k, e, K, c, I, h, r) {\n      var f = [],\n          v = I - c;\n      return I > c && I - c > Math.PI / 2 + .0001 ? (f = f.concat(n(a, k, e, K, c, c + Math.PI / 2, h, r)), f = f.concat(n(a, k, e, K, c + Math.PI / 2, I, h, r))) : I < c && c - I > Math.PI / 2 + .0001 ? (f = f.concat(n(a, k, e, K, c, c - Math.PI / 2, h, r)), f = f.concat(n(a, k, e, K, c - Math.PI / 2, I, h, r))) : [[\"C\", a + e * Math.cos(c) - e * J * v * Math.sin(c) + h, k + K * Math.sin(c) + K * J * v * Math.cos(c) + r, a + e * Math.cos(I) + e * J * v * Math.sin(I) + h, k + K * Math.sin(I) - K * J * v * Math.cos(I) + r, a + e * Math.cos(I) + h, k + K * Math.sin(I) + r]];\n    }\n\n    var q = b.parse,\n        D = w.animObject,\n        m = w.defined,\n        u = w.extend,\n        g = w.merge,\n        p = w.objectEach,\n        E = w.pick,\n        y = Math.cos,\n        a = Math.PI,\n        k = Math.sin,\n        x = t.charts,\n        c = t.deg2rad,\n        h = t.perspective;\n    var J = 4 * (Math.sqrt(2) - 1) / 3 / (a / 2);\n\n    d.prototype.toLinePath = function (a, c) {\n      var e = [];\n      a.forEach(function (a) {\n        e.push([\"L\", a.x, a.y]);\n      });\n      a.length && (e[0][0] = \"M\", c && e.push([\"Z\"]));\n      return e;\n    };\n\n    d.prototype.toLineSegments = function (a) {\n      var f = [],\n          e = !0;\n      a.forEach(function (a) {\n        f.push(e ? [\"M\", a.x, a.y] : [\"L\", a.x, a.y]);\n        e = !e;\n      });\n      return f;\n    };\n\n    d.prototype.face3d = function (a) {\n      var f = this,\n          e = this.createElement(\"path\");\n      e.vertexes = [];\n      e.insidePlotArea = !1;\n      e.enabled = !0;\n\n      e.attr = function (a) {\n        if (\"object\" === typeof a && (m(a.enabled) || m(a.vertexes) || m(a.insidePlotArea))) {\n          this.enabled = E(a.enabled, this.enabled);\n          this.vertexes = E(a.vertexes, this.vertexes);\n          this.insidePlotArea = E(a.insidePlotArea, this.insidePlotArea);\n          delete a.enabled;\n          delete a.vertexes;\n          delete a.insidePlotArea;\n          var e = h(this.vertexes, x[f.chartIndex], this.insidePlotArea),\n              c = f.toLinePath(e, !0);\n          e = t.shapeArea(e);\n          e = this.enabled && 0 < e ? \"visible\" : \"hidden\";\n          a.d = c;\n          a.visibility = e;\n        }\n\n        return l.prototype.attr.apply(this, arguments);\n      };\n\n      e.animate = function (a) {\n        if (\"object\" === typeof a && (m(a.enabled) || m(a.vertexes) || m(a.insidePlotArea))) {\n          this.enabled = E(a.enabled, this.enabled);\n          this.vertexes = E(a.vertexes, this.vertexes);\n          this.insidePlotArea = E(a.insidePlotArea, this.insidePlotArea);\n          delete a.enabled;\n          delete a.vertexes;\n          delete a.insidePlotArea;\n          var e = h(this.vertexes, x[f.chartIndex], this.insidePlotArea),\n              c = f.toLinePath(e, !0);\n          e = t.shapeArea(e);\n          e = this.enabled && 0 < e ? \"visible\" : \"hidden\";\n          a.d = c;\n          this.attr(\"visibility\", e);\n        }\n\n        return l.prototype.animate.apply(this, arguments);\n      };\n\n      return e.attr(a);\n    };\n\n    d.prototype.polyhedron = function (a) {\n      var f = this,\n          e = this.g(),\n          c = e.destroy;\n      this.styledMode || e.attr({\n        \"stroke-linejoin\": \"round\"\n      });\n      e.faces = [];\n\n      e.destroy = function () {\n        for (var a = 0; a < e.faces.length; a++) {\n          e.faces[a].destroy();\n        }\n\n        return c.call(this);\n      };\n\n      e.attr = function (a, c, k, r) {\n        if (\"object\" === typeof a && m(a.faces)) {\n          for (; e.faces.length > a.faces.length;) {\n            e.faces.pop().destroy();\n          }\n\n          for (; e.faces.length < a.faces.length;) {\n            e.faces.push(f.face3d().add(e));\n          }\n\n          for (var h = 0; h < a.faces.length; h++) {\n            f.styledMode && delete a.faces[h].fill, e.faces[h].attr(a.faces[h], null, k, r);\n          }\n\n          delete a.faces;\n        }\n\n        return l.prototype.attr.apply(this, arguments);\n      };\n\n      e.animate = function (a, c, k) {\n        if (a && a.faces) {\n          for (; e.faces.length > a.faces.length;) {\n            e.faces.pop().destroy();\n          }\n\n          for (; e.faces.length < a.faces.length;) {\n            e.faces.push(f.face3d().add(e));\n          }\n\n          for (var r = 0; r < a.faces.length; r++) {\n            e.faces[r].animate(a.faces[r], c, k);\n          }\n\n          delete a.faces;\n        }\n\n        return l.prototype.animate.apply(this, arguments);\n      };\n\n      return e.attr(a);\n    };\n\n    b = {\n      initArgs: function initArgs(a) {\n        var f = this,\n            e = f.renderer,\n            c = e[f.pathType + \"Path\"](a),\n            k = c.zIndexes;\n        f.parts.forEach(function (a) {\n          f[a] = e.path(c[a]).attr({\n            \"class\": \"highcharts-3d-\" + a,\n            zIndex: k[a] || 0\n          }).add(f);\n        });\n        f.attr({\n          \"stroke-linejoin\": \"round\",\n          zIndex: k.group\n        });\n        f.originalDestroy = f.destroy;\n        f.destroy = f.destroyParts;\n        f.forcedSides = c.forcedSides;\n      },\n      singleSetterForParts: function singleSetterForParts(a, c, e, k, h, d) {\n        var f = {};\n        k = [null, null, k || \"attr\", h, d];\n        var r = e && e.zIndexes;\n        e ? (r && r.group && this.attr({\n          zIndex: r.group\n        }), p(e, function (c, v) {\n          f[v] = {};\n          f[v][a] = c;\n          r && (f[v].zIndex = e.zIndexes[v] || 0);\n        }), k[1] = f) : (f[a] = c, k[0] = f);\n        return this.processParts.apply(this, k);\n      },\n      processParts: function processParts(a, c, e, k, h) {\n        var f = this;\n        f.parts.forEach(function (d) {\n          c && (a = E(c[d], !1));\n          if (!1 !== a) f[d][e](a, k, h);\n        });\n        return f;\n      },\n      destroyParts: function destroyParts() {\n        this.processParts(null, null, \"destroy\");\n        return this.originalDestroy();\n      }\n    };\n    var M = g(b, {\n      parts: [\"front\", \"top\", \"side\"],\n      pathType: \"cuboid\",\n      attr: function attr(a, c, e, k) {\n        if (\"string\" === typeof a && \"undefined\" !== typeof c) {\n          var f = a;\n          a = {};\n          a[f] = c;\n        }\n\n        return a.shapeArgs || m(a.x) ? this.singleSetterForParts(\"d\", null, this.renderer[this.pathType + \"Path\"](a.shapeArgs || a)) : l.prototype.attr.call(this, a, void 0, e, k);\n      },\n      animate: function animate(a, c, e) {\n        if (m(a.x) && m(a.y)) {\n          a = this.renderer[this.pathType + \"Path\"](a);\n          var f = a.forcedSides;\n          this.singleSetterForParts(\"d\", null, a, \"animate\", c, e);\n          this.attr({\n            zIndex: a.zIndexes.group\n          });\n          f !== this.forcedSides && (this.forcedSides = f, M.fillSetter.call(this, this.fill));\n        } else l.prototype.animate.call(this, a, c, e);\n\n        return this;\n      },\n      fillSetter: function fillSetter(a) {\n        this.forcedSides = this.forcedSides || [];\n        this.singleSetterForParts(\"fill\", null, {\n          front: a,\n          top: q(a).brighten(0 <= this.forcedSides.indexOf(\"top\") ? 0 : .1).get(),\n          side: q(a).brighten(0 <= this.forcedSides.indexOf(\"side\") ? 0 : -.1).get()\n        });\n        this.color = this.fill = a;\n        return this;\n      }\n    });\n    d.prototype.elements3d = {\n      base: b,\n      cuboid: M\n    };\n\n    d.prototype.element3d = function (a, c) {\n      var e = this.g();\n      u(e, this.elements3d[a]);\n      e.initArgs(c);\n      return e;\n    };\n\n    d.prototype.cuboid = function (a) {\n      return this.element3d(\"cuboid\", a);\n    };\n\n    d.prototype.cuboidPath = function (a) {\n      function c(a) {\n        return 0 === y && 1 < a && 6 > a ? {\n          x: B[a].x,\n          y: B[a].y + 10,\n          z: B[a].z\n        } : B[0].x === B[7].x && 4 <= a ? {\n          x: B[a].x + 10,\n          y: B[a].y,\n          z: B[a].z\n        } : 0 === G && 2 > a || 5 < a ? {\n          x: B[a].x,\n          y: B[a].y,\n          z: B[a].z + 10\n        } : B[a];\n      }\n\n      function e(a) {\n        return B[a];\n      }\n\n      var f = a.x,\n          k = a.y,\n          d = a.z || 0,\n          y = a.height,\n          r = a.width,\n          G = a.depth,\n          v = x[this.chartIndex],\n          z = v.options.chart.options3d.alpha,\n          H = 0,\n          B = [{\n        x: f,\n        y: k,\n        z: d\n      }, {\n        x: f + r,\n        y: k,\n        z: d\n      }, {\n        x: f + r,\n        y: k + y,\n        z: d\n      }, {\n        x: f,\n        y: k + y,\n        z: d\n      }, {\n        x: f,\n        y: k + y,\n        z: d + G\n      }, {\n        x: f + r,\n        y: k + y,\n        z: d + G\n      }, {\n        x: f + r,\n        y: k,\n        z: d + G\n      }, {\n        x: f,\n        y: k,\n        z: d + G\n      }],\n          N = [];\n      B = h(B, v, a.insidePlotArea);\n\n      var A = function A(a, v, f) {\n        var k = [[], -1],\n            r = a.map(e),\n            z = v.map(e);\n        a = a.map(c);\n        v = v.map(c);\n        0 > t.shapeArea(r) ? k = [r, 0] : 0 > t.shapeArea(z) ? k = [z, 1] : f && (N.push(f), k = 0 > t.shapeArea(a) ? [r, 0] : 0 > t.shapeArea(v) ? [z, 1] : [r, 0]);\n        return k;\n      };\n\n      var C = A([3, 2, 1, 0], [7, 6, 5, 4], \"front\");\n      a = C[0];\n      var b = C[1];\n      C = A([1, 6, 7, 0], [4, 5, 2, 3], \"top\");\n      r = C[0];\n      var n = C[1];\n      C = A([1, 2, 5, 6], [0, 7, 4, 3], \"side\");\n      A = C[0];\n      C = C[1];\n      1 === C ? H += 1E6 * (v.plotWidth - f) : C || (H += 1E6 * f);\n      H += 10 * (!n || 0 <= z && 180 >= z || 360 > z && 357.5 < z ? v.plotHeight - k : 10 + k);\n      1 === b ? H += 100 * d : b || (H += 100 * (1E3 - d));\n      return {\n        front: this.toLinePath(a, !0),\n        top: this.toLinePath(r, !0),\n        side: this.toLinePath(A, !0),\n        zIndexes: {\n          group: Math.round(H)\n        },\n        forcedSides: N,\n        isFront: b,\n        isTop: n\n      };\n    };\n\n    d.prototype.arc3d = function (a) {\n      function k(a) {\n        var e = !1,\n            k = {},\n            c;\n        a = g(a);\n\n        for (c in a) {\n          -1 !== h.indexOf(c) && (k[c] = a[c], delete a[c], e = !0);\n        }\n\n        return e ? [k, a] : !1;\n      }\n\n      var e = this.g(),\n          f = e.renderer,\n          h = \"x y r innerR start end depth\".split(\" \");\n      a = g(a);\n      a.alpha = (a.alpha || 0) * c;\n      a.beta = (a.beta || 0) * c;\n      e.top = f.path();\n      e.side1 = f.path();\n      e.side2 = f.path();\n      e.inn = f.path();\n      e.out = f.path();\n\n      e.onAdd = function () {\n        var a = e.parentGroup,\n            c = e.attr(\"class\");\n        e.top.add(e);\n        [\"out\", \"inn\", \"side1\", \"side2\"].forEach(function (k) {\n          e[k].attr({\n            \"class\": c + \" highcharts-3d-side\"\n          }).add(a);\n        });\n      };\n\n      [\"addClass\", \"removeClass\"].forEach(function (a) {\n        e[a] = function () {\n          var c = arguments;\n          [\"top\", \"out\", \"inn\", \"side1\", \"side2\"].forEach(function (k) {\n            e[k][a].apply(e[k], c);\n          });\n        };\n      });\n\n      e.setPaths = function (a) {\n        var k = e.renderer.arc3dPath(a),\n            c = 100 * k.zTop;\n        e.attribs = a;\n        e.top.attr({\n          d: k.top,\n          zIndex: k.zTop\n        });\n        e.inn.attr({\n          d: k.inn,\n          zIndex: k.zInn\n        });\n        e.out.attr({\n          d: k.out,\n          zIndex: k.zOut\n        });\n        e.side1.attr({\n          d: k.side1,\n          zIndex: k.zSide1\n        });\n        e.side2.attr({\n          d: k.side2,\n          zIndex: k.zSide2\n        });\n        e.zIndex = c;\n        e.attr({\n          zIndex: c\n        });\n        a.center && (e.top.setRadialReference(a.center), delete a.center);\n      };\n\n      e.setPaths(a);\n\n      e.fillSetter = function (a) {\n        var e = q(a).brighten(-.1).get();\n        this.fill = a;\n        this.side1.attr({\n          fill: e\n        });\n        this.side2.attr({\n          fill: e\n        });\n        this.inn.attr({\n          fill: e\n        });\n        this.out.attr({\n          fill: e\n        });\n        this.top.attr({\n          fill: a\n        });\n        return this;\n      };\n\n      [\"opacity\", \"translateX\", \"translateY\", \"visibility\"].forEach(function (a) {\n        e[a + \"Setter\"] = function (a, k) {\n          e[k] = a;\n          [\"out\", \"inn\", \"side1\", \"side2\", \"top\"].forEach(function (c) {\n            e[c].attr(k, a);\n          });\n        };\n      });\n\n      e.attr = function (a) {\n        var c;\n\n        if (\"object\" === typeof a && (c = k(a))) {\n          var f = c[0];\n          arguments[0] = c[1];\n          u(e.attribs, f);\n          e.setPaths(e.attribs);\n        }\n\n        return l.prototype.attr.apply(e, arguments);\n      };\n\n      e.animate = function (a, c, f) {\n        var r = this.attribs,\n            v = \"data-\" + Math.random().toString(26).substring(2, 9);\n        delete a.center;\n        delete a.z;\n        delete a.alpha;\n        delete a.beta;\n        var z = D(E(c, this.renderer.globalAnimation));\n\n        if (z.duration) {\n          c = k(a);\n          e[v] = 0;\n          a[v] = 1;\n          e[v + \"Setter\"] = t.noop;\n\n          if (c) {\n            var h = c[0];\n\n            z.step = function (a, e) {\n              function c(a) {\n                return r[a] + (E(h[a], r[a]) - r[a]) * e.pos;\n              }\n\n              e.prop === v && e.elem.setPaths(g(r, {\n                x: c(\"x\"),\n                y: c(\"y\"),\n                r: c(\"r\"),\n                innerR: c(\"innerR\"),\n                start: c(\"start\"),\n                end: c(\"end\"),\n                depth: c(\"depth\")\n              }));\n            };\n          }\n\n          c = z;\n        }\n\n        return l.prototype.animate.call(this, a, c, f);\n      };\n\n      e.destroy = function () {\n        this.top.destroy();\n        this.out.destroy();\n        this.inn.destroy();\n        this.side1.destroy();\n        this.side2.destroy();\n        return l.prototype.destroy.call(this);\n      };\n\n      e.hide = function () {\n        this.top.hide();\n        this.out.hide();\n        this.inn.hide();\n        this.side1.hide();\n        this.side2.hide();\n      };\n\n      e.show = function (a) {\n        this.top.show(a);\n        this.out.show(a);\n        this.inn.show(a);\n        this.side1.show(a);\n        this.side2.show(a);\n      };\n\n      return e;\n    };\n\n    d.prototype.arc3dPath = function (c) {\n      function f(a) {\n        a %= 2 * Math.PI;\n        a > Math.PI && (a = 2 * Math.PI - a);\n        return a;\n      }\n\n      var e = c.x,\n          h = c.y,\n          d = c.start,\n          x = c.end - .00001,\n          b = c.r,\n          r = c.innerR || 0,\n          G = c.depth || 0,\n          v = c.alpha,\n          z = c.beta,\n          H = Math.cos(d),\n          B = Math.sin(d);\n      c = Math.cos(x);\n      var q = Math.sin(x),\n          A = b * Math.cos(z);\n      b *= Math.cos(v);\n      var C = r * Math.cos(z),\n          p = r * Math.cos(v);\n      r = G * Math.sin(z);\n      var m = G * Math.sin(v);\n      G = [[\"M\", e + A * H, h + b * B]];\n      G = G.concat(n(e, h, A, b, d, x, 0, 0));\n      G.push([\"L\", e + C * c, h + p * q]);\n      G = G.concat(n(e, h, C, p, x, d, 0, 0));\n      G.push([\"Z\"]);\n      var u = 0 < z ? Math.PI / 2 : 0;\n      z = 0 < v ? 0 : Math.PI / 2;\n      u = d > -u ? d : x > -u ? -u : d;\n      var g = x < a - z ? x : d < a - z ? a - z : x,\n          l = 2 * a - z;\n      v = [[\"M\", e + A * y(u), h + b * k(u)]];\n      v = v.concat(n(e, h, A, b, u, g, 0, 0));\n      x > l && d < l ? (v.push([\"L\", e + A * y(g) + r, h + b * k(g) + m]), v = v.concat(n(e, h, A, b, g, l, r, m)), v.push([\"L\", e + A * y(l), h + b * k(l)]), v = v.concat(n(e, h, A, b, l, x, 0, 0)), v.push([\"L\", e + A * y(x) + r, h + b * k(x) + m]), v = v.concat(n(e, h, A, b, x, l, r, m)), v.push([\"L\", e + A * y(l), h + b * k(l)]), v = v.concat(n(e, h, A, b, l, g, 0, 0))) : x > a - z && d < a - z && (v.push([\"L\", e + A * Math.cos(g) + r, h + b * Math.sin(g) + m]), v = v.concat(n(e, h, A, b, g, x, r, m)), v.push([\"L\", e + A * Math.cos(x), h + b * Math.sin(x)]), v = v.concat(n(e, h, A, b, x, g, 0, 0)));\n      v.push([\"L\", e + A * Math.cos(g) + r, h + b * Math.sin(g) + m]);\n      v = v.concat(n(e, h, A, b, g, u, r, m));\n      v.push([\"Z\"]);\n      z = [[\"M\", e + C * H, h + p * B]];\n      z = z.concat(n(e, h, C, p, d, x, 0, 0));\n      z.push([\"L\", e + C * Math.cos(x) + r, h + p * Math.sin(x) + m]);\n      z = z.concat(n(e, h, C, p, x, d, r, m));\n      z.push([\"Z\"]);\n      H = [[\"M\", e + A * H, h + b * B], [\"L\", e + A * H + r, h + b * B + m], [\"L\", e + C * H + r, h + p * B + m], [\"L\", e + C * H, h + p * B], [\"Z\"]];\n      e = [[\"M\", e + A * c, h + b * q], [\"L\", e + A * c + r, h + b * q + m], [\"L\", e + C * c + r, h + p * q + m], [\"L\", e + C * c, h + p * q], [\"Z\"]];\n      q = Math.atan2(m, -r);\n      h = Math.abs(x + q);\n      c = Math.abs(d + q);\n      d = Math.abs((d + x) / 2 + q);\n      h = f(h);\n      c = f(c);\n      d = f(d);\n      d *= 1E5;\n      x = 1E5 * c;\n      h *= 1E5;\n      return {\n        top: G,\n        zTop: 1E5 * Math.PI + 1,\n        out: v,\n        zOut: Math.max(d, x, h),\n        inn: z,\n        zInn: Math.max(d, x, h),\n        side1: H,\n        zSide1: .99 * h,\n        side2: e,\n        zSide2: .99 * x\n      };\n    };\n  });\n  F(b, \"parts-3d/Tick3D.js\", [b[\"parts/Utilities.js\"]], function (b) {\n    var t = b.addEvent,\n        l = b.extend,\n        d = b.wrap;\n    return function () {\n      function b() {}\n\n      b.compose = function (n) {\n        t(n, \"afterGetLabelPosition\", b.onAfterGetLabelPosition);\n        d(n.prototype, \"getMarkPath\", b.wrapGetMarkPath);\n      };\n\n      b.onAfterGetLabelPosition = function (d) {\n        var b = this.axis.axis3D;\n        b && l(d.pos, b.fix3dPosition(d.pos));\n      };\n\n      b.wrapGetMarkPath = function (d) {\n        var b = this.axis.axis3D,\n            n = d.apply(this, [].slice.call(arguments, 1));\n\n        if (b) {\n          var m = n[0],\n              u = n[1];\n          if (\"M\" === m[0] && \"L\" === u[0]) return b = [b.fix3dPosition({\n            x: m[1],\n            y: m[2],\n            z: 0\n          }), b.fix3dPosition({\n            x: u[1],\n            y: u[2],\n            z: 0\n          })], this.axis.chart.renderer.toLineSegments(b);\n        }\n\n        return n;\n      };\n\n      return b;\n    }();\n  });\n  F(b, \"parts-3d/Axis3D.js\", [b[\"parts/Globals.js\"], b[\"parts/Tick.js\"], b[\"parts-3d/Tick3D.js\"], b[\"parts/Utilities.js\"]], function (b, t, l, d) {\n    var w = d.addEvent,\n        n = d.merge,\n        q = d.pick,\n        D = d.wrap,\n        m = b.deg2rad,\n        u = b.perspective,\n        g = b.perspective3D,\n        p = b.shapeArea,\n        E = function () {\n      function d(a) {\n        this.axis = a;\n      }\n\n      d.prototype.fix3dPosition = function (a, k) {\n        var d = this.axis,\n            c = d.chart;\n        if (\"colorAxis\" === d.coll || !c.chart3d || !c.is3d()) return a;\n        var h = m * c.options.chart.options3d.alpha,\n            b = m * c.options.chart.options3d.beta,\n            y = q(k && d.options.title.position3d, d.options.labels.position3d);\n        k = q(k && d.options.title.skew3d, d.options.labels.skew3d);\n        var f = c.chart3d.frame3d,\n            g = c.plotLeft,\n            e = c.plotWidth + g,\n            n = c.plotTop,\n            l = c.plotHeight + n;\n        c = !1;\n        var t = 0,\n            w = 0,\n            r = {\n          x: 0,\n          y: 1,\n          z: 0\n        };\n        a = d.axis3D.swapZ({\n          x: a.x,\n          y: a.y,\n          z: 0\n        });\n        if (d.isZAxis) {\n          if (d.opposite) {\n            if (null === f.axes.z.top) return {};\n            w = a.y - n;\n            a.x = f.axes.z.top.x;\n            a.y = f.axes.z.top.y;\n            g = f.axes.z.top.xDir;\n            c = !f.top.frontFacing;\n          } else {\n            if (null === f.axes.z.bottom) return {};\n            w = a.y - l;\n            a.x = f.axes.z.bottom.x;\n            a.y = f.axes.z.bottom.y;\n            g = f.axes.z.bottom.xDir;\n            c = !f.bottom.frontFacing;\n          }\n        } else if (d.horiz) {\n          if (d.opposite) {\n            if (null === f.axes.x.top) return {};\n            w = a.y - n;\n            a.y = f.axes.x.top.y;\n            a.z = f.axes.x.top.z;\n            g = f.axes.x.top.xDir;\n            c = !f.top.frontFacing;\n          } else {\n            if (null === f.axes.x.bottom) return {};\n            w = a.y - l;\n            a.y = f.axes.x.bottom.y;\n            a.z = f.axes.x.bottom.z;\n            g = f.axes.x.bottom.xDir;\n            c = !f.bottom.frontFacing;\n          }\n        } else if (d.opposite) {\n          if (null === f.axes.y.right) return {};\n          t = a.x - e;\n          a.x = f.axes.y.right.x;\n          a.z = f.axes.y.right.z;\n          g = f.axes.y.right.xDir;\n          g = {\n            x: g.z,\n            y: g.y,\n            z: -g.x\n          };\n        } else {\n          if (null === f.axes.y.left) return {};\n          t = a.x - g;\n          a.x = f.axes.y.left.x;\n          a.z = f.axes.y.left.z;\n          g = f.axes.y.left.xDir;\n        }\n        \"chart\" !== y && (\"flap\" === y ? d.horiz ? (b = Math.sin(h), h = Math.cos(h), d.opposite && (b = -b), c && (b = -b), r = {\n          x: g.z * b,\n          y: h,\n          z: -g.x * b\n        }) : g = {\n          x: Math.cos(b),\n          y: 0,\n          z: Math.sin(b)\n        } : \"ortho\" === y ? d.horiz ? (r = Math.cos(h), y = Math.sin(b) * r, h = -Math.sin(h), b = -r * Math.cos(b), r = {\n          x: g.y * b - g.z * h,\n          y: g.z * y - g.x * b,\n          z: g.x * h - g.y * y\n        }, h = 1 / Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z), c && (h = -h), r = {\n          x: h * r.x,\n          y: h * r.y,\n          z: h * r.z\n        }) : g = {\n          x: Math.cos(b),\n          y: 0,\n          z: Math.sin(b)\n        } : d.horiz ? r = {\n          x: Math.sin(b) * Math.sin(h),\n          y: Math.cos(h),\n          z: -Math.cos(b) * Math.sin(h)\n        } : g = {\n          x: Math.cos(b),\n          y: 0,\n          z: Math.sin(b)\n        });\n        a.x += t * g.x + w * r.x;\n        a.y += t * g.y + w * r.y;\n        a.z += t * g.z + w * r.z;\n        c = u([a], d.chart)[0];\n        k && (0 > p(u([a, {\n          x: a.x + g.x,\n          y: a.y + g.y,\n          z: a.z + g.z\n        }, {\n          x: a.x + r.x,\n          y: a.y + r.y,\n          z: a.z + r.z\n        }], d.chart)) && (g = {\n          x: -g.x,\n          y: -g.y,\n          z: -g.z\n        }), a = u([{\n          x: a.x,\n          y: a.y,\n          z: a.z\n        }, {\n          x: a.x + g.x,\n          y: a.y + g.y,\n          z: a.z + g.z\n        }, {\n          x: a.x + r.x,\n          y: a.y + r.y,\n          z: a.z + r.z\n        }], d.chart), c.matrix = [a[1].x - a[0].x, a[1].y - a[0].y, a[2].x - a[0].x, a[2].y - a[0].y, c.x, c.y], c.matrix[4] -= c.x * c.matrix[0] + c.y * c.matrix[2], c.matrix[5] -= c.x * c.matrix[1] + c.y * c.matrix[3]);\n        return c;\n      };\n\n      d.prototype.swapZ = function (a, k) {\n        var d = this.axis;\n        return d.isZAxis ? (k = k ? 0 : d.chart.plotLeft, {\n          x: k + a.z,\n          y: a.y,\n          z: a.x - k\n        }) : a;\n      };\n\n      return d;\n    }();\n\n    return function () {\n      function d() {}\n\n      d.compose = function (a) {\n        n(!0, a.defaultOptions, d.defaultOptions);\n        a.keepProps.push(\"axis3D\");\n        w(a, \"init\", d.onInit);\n        w(a, \"afterSetOptions\", d.onAfterSetOptions);\n        w(a, \"drawCrosshair\", d.onDrawCrosshair);\n        w(a, \"destroy\", d.onDestroy);\n        a = a.prototype;\n        D(a, \"getLinePath\", d.wrapGetLinePath);\n        D(a, \"getPlotBandPath\", d.wrapGetPlotBandPath);\n        D(a, \"getPlotLinePath\", d.wrapGetPlotLinePath);\n        D(a, \"getSlotWidth\", d.wrapGetSlotWidth);\n        D(a, \"getTitlePosition\", d.wrapGetTitlePosition);\n        l.compose(t);\n      };\n\n      d.onAfterSetOptions = function () {\n        var a = this.chart,\n            d = this.options;\n        a.is3d && a.is3d() && \"colorAxis\" !== this.coll && (d.tickWidth = q(d.tickWidth, 0), d.gridLineWidth = q(d.gridLineWidth, 1));\n      };\n\n      d.onDestroy = function () {\n        [\"backFrame\", \"bottomFrame\", \"sideFrame\"].forEach(function (a) {\n          this[a] && (this[a] = this[a].destroy());\n        }, this);\n      };\n\n      d.onDrawCrosshair = function (a) {\n        this.chart.is3d() && \"colorAxis\" !== this.coll && a.point && (a.point.crosshairPos = this.isXAxis ? a.point.axisXpos : this.len - a.point.axisYpos);\n      };\n\n      d.onInit = function () {\n        this.axis3D || (this.axis3D = new E(this));\n      };\n\n      d.wrapGetLinePath = function (a) {\n        return this.chart.is3d() && \"colorAxis\" !== this.coll ? [] : a.apply(this, [].slice.call(arguments, 1));\n      };\n\n      d.wrapGetPlotBandPath = function (a) {\n        if (!this.chart.is3d() || \"colorAxis\" === this.coll) return a.apply(this, [].slice.call(arguments, 1));\n        var d = arguments,\n            b = d[2],\n            c = [];\n        d = this.getPlotLinePath({\n          value: d[1]\n        });\n        b = this.getPlotLinePath({\n          value: b\n        });\n        if (d && b) for (var h = 0; h < d.length; h += 2) {\n          var g = d[h],\n              p = d[h + 1],\n              f = b[h],\n              m = b[h + 1];\n          \"M\" === g[0] && \"L\" === p[0] && \"M\" === f[0] && \"L\" === m[0] && c.push(g, p, m, [\"L\", f[1], f[2]], [\"Z\"]);\n        }\n        return c;\n      };\n\n      d.wrapGetPlotLinePath = function (a) {\n        var d = this.axis3D,\n            b = this.chart,\n            c = a.apply(this, [].slice.call(arguments, 1));\n        if (\"colorAxis\" === this.coll || !b.chart3d || !b.is3d() || null === c) return c;\n        var h = b.options.chart.options3d,\n            g = this.isZAxis ? b.plotWidth : h.depth;\n        h = b.chart3d.frame3d;\n        var p = c[0],\n            f = c[1];\n        c = [];\n        \"M\" === p[0] && \"L\" === f[0] && (d = [d.swapZ({\n          x: p[1],\n          y: p[2],\n          z: 0\n        }), d.swapZ({\n          x: p[1],\n          y: p[2],\n          z: g\n        }), d.swapZ({\n          x: f[1],\n          y: f[2],\n          z: 0\n        }), d.swapZ({\n          x: f[1],\n          y: f[2],\n          z: g\n        })], this.horiz ? (this.isZAxis ? (h.left.visible && c.push(d[0], d[2]), h.right.visible && c.push(d[1], d[3])) : (h.front.visible && c.push(d[0], d[2]), h.back.visible && c.push(d[1], d[3])), h.top.visible && c.push(d[0], d[1]), h.bottom.visible && c.push(d[2], d[3])) : (h.front.visible && c.push(d[0], d[2]), h.back.visible && c.push(d[1], d[3]), h.left.visible && c.push(d[0], d[1]), h.right.visible && c.push(d[2], d[3])), c = u(c, this.chart, !1));\n        return b.renderer.toLineSegments(c);\n      };\n\n      d.wrapGetSlotWidth = function (a, d) {\n        var b = this.chart,\n            c = this.ticks,\n            h = this.gridGroup;\n\n        if (this.categories && b.frameShapes && b.is3d() && h && d && d.label) {\n          h = h.element.childNodes[0].getBBox();\n          var k = b.frameShapes.left.getBBox(),\n              p = b.options.chart.options3d;\n          b = {\n            x: b.plotWidth / 2,\n            y: b.plotHeight / 2,\n            z: p.depth / 2,\n            vd: q(p.depth, 1) * q(p.viewDistance, 0)\n          };\n          var f, m;\n          p = d.pos;\n          var e = c[p - 1];\n          c = c[p + 1];\n          0 !== p && e && e.label.xy && (f = g({\n            x: e.label.xy.x,\n            y: e.label.xy.y,\n            z: null\n          }, b, b.vd));\n          c && c.label.xy && (m = g({\n            x: c.label.xy.x,\n            y: c.label.xy.y,\n            z: null\n          }, b, b.vd));\n          c = {\n            x: d.label.xy.x,\n            y: d.label.xy.y,\n            z: null\n          };\n          c = g(c, b, b.vd);\n          return Math.abs(f ? c.x - f.x : m ? m.x - c.x : h.x - k.x);\n        }\n\n        return a.apply(this, [].slice.call(arguments, 1));\n      };\n\n      d.wrapGetTitlePosition = function (a) {\n        var d = a.apply(this, [].slice.call(arguments, 1));\n        return this.axis3D ? this.axis3D.fix3dPosition(d, !0) : d;\n      };\n\n      d.defaultOptions = {\n        labels: {\n          position3d: \"offset\",\n          skew3d: !1\n        },\n        title: {\n          position3d: null,\n          skew3d: null\n        }\n      };\n      return d;\n    }();\n  });\n  F(b, \"parts-3d/ZAxis.js\", [b[\"parts/Axis.js\"], b[\"parts/Utilities.js\"]], function (b, t) {\n    var l = this && this.__extends || function () {\n      var _d = function d(b, p) {\n        _d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var a in b) {\n            b.hasOwnProperty(a) && (d[a] = b[a]);\n          }\n        };\n\n        return _d(b, p);\n      };\n\n      return function (b, p) {\n        function g() {\n          this.constructor = b;\n        }\n\n        _d(b, p);\n\n        b.prototype = null === p ? Object.create(p) : (g.prototype = p.prototype, new g());\n      };\n    }(),\n        d = t.addEvent,\n        w = t.merge,\n        n = t.pick,\n        q = t.splat,\n        D = function () {\n      function b() {}\n\n      b.compose = function (g) {\n        d(g, \"afterGetAxes\", b.onAfterGetAxes);\n        g = g.prototype;\n        g.addZAxis = b.wrapAddZAxis;\n        g.collectionsWithInit.zAxis = [g.addZAxis];\n        g.collectionsWithUpdate.push(\"zAxis\");\n      };\n\n      b.onAfterGetAxes = function () {\n        var d = this,\n            b = this.options;\n        b = b.zAxis = q(b.zAxis || {});\n        d.is3d() && (d.zAxis = [], b.forEach(function (b, g) {\n          b.index = g;\n          b.isX = !0;\n          d.addZAxis(b).setScale();\n        }));\n      };\n\n      b.wrapAddZAxis = function (d) {\n        return new m(this, d);\n      };\n\n      return b;\n    }(),\n        m = function (d) {\n      function b(b, g) {\n        b = d.call(this, b, g) || this;\n        b.isZAxis = !0;\n        return b;\n      }\n\n      l(b, d);\n\n      b.prototype.getSeriesExtremes = function () {\n        var d = this,\n            b = d.chart;\n        d.hasVisibleSeries = !1;\n        d.dataMin = d.dataMax = d.ignoreMinPadding = d.ignoreMaxPadding = void 0;\n        d.stacking && d.stacking.buildStacks();\n        d.series.forEach(function (g) {\n          !g.visible && b.options.chart && b.options.chart.ignoreHiddenSeries || (d.hasVisibleSeries = !0, g = g.zData, g.length && (d.dataMin = Math.min(n(d.dataMin, g[0]), Math.min.apply(null, g)), d.dataMax = Math.max(n(d.dataMax, g[0]), Math.max.apply(null, g))));\n        });\n      };\n\n      b.prototype.setAxisSize = function () {\n        var b = this.chart;\n        d.prototype.setAxisSize.call(this);\n        this.width = this.len = b.options.chart && b.options.chart.options3d && b.options.chart.options3d.depth || 0;\n        this.right = b.chartWidth - this.width - this.left;\n      };\n\n      b.prototype.setOptions = function (b) {\n        b = w({\n          offset: 0,\n          lineWidth: 0\n        }, b);\n        d.prototype.setOptions.call(this, b);\n        this.coll = \"zAxis\";\n      };\n\n      b.ZChartComposition = D;\n      return b;\n    }(b);\n\n    return m;\n  });\n  F(b, \"parts-3d/Chart3D.js\", [b[\"parts/Axis.js\"], b[\"parts-3d/Axis3D.js\"], b[\"parts/Chart.js\"], b[\"parts/Globals.js\"], b[\"parts/Options.js\"], b[\"parts/Utilities.js\"], b[\"parts-3d/ZAxis.js\"]], function (b, t, l, d, w, n, q) {\n    var D = w.defaultOptions,\n        m = n.addEvent;\n    w = n.Fx;\n    var u = n.isArray,\n        g = n.merge,\n        p = n.pick,\n        E = n.wrap,\n        y = d.perspective,\n        a;\n\n    (function (a) {\n      function b(a) {\n        this.is3d() && \"scatter\" === a.options.type && (a.options.type = \"scatter3d\");\n      }\n\n      function c() {\n        if (this.chart3d && this.is3d()) {\n          var a = this.renderer,\n              b = this.options.chart.options3d,\n              c = this.chart3d.get3dFrame(),\n              e = this.plotLeft,\n              h = this.plotLeft + this.plotWidth,\n              f = this.plotTop,\n              k = this.plotTop + this.plotHeight;\n          b = b.depth;\n          var g = e - (c.left.visible ? c.left.size : 0),\n              m = h + (c.right.visible ? c.right.size : 0),\n              n = f - (c.top.visible ? c.top.size : 0),\n              q = k + (c.bottom.visible ? c.bottom.size : 0),\n              l = 0 - (c.front.visible ? c.front.size : 0),\n              p = b + (c.back.visible ? c.back.size : 0),\n              y = this.hasRendered ? \"animate\" : \"attr\";\n          this.chart3d.frame3d = c;\n          this.frameShapes || (this.frameShapes = {\n            bottom: a.polyhedron().add(),\n            top: a.polyhedron().add(),\n            left: a.polyhedron().add(),\n            right: a.polyhedron().add(),\n            back: a.polyhedron().add(),\n            front: a.polyhedron().add()\n          });\n          this.frameShapes.bottom[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-bottom\",\n            zIndex: c.bottom.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: g,\n                y: q,\n                z: p\n              }],\n              enabled: c.bottom.visible\n            }, {\n              fill: d.color(c.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }],\n              enabled: c.bottom.visible\n            }, {\n              fill: d.color(c.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }],\n              enabled: c.bottom.visible && !c.left.visible\n            }, {\n              fill: d.color(c.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }],\n              enabled: c.bottom.visible && !c.right.visible\n            }, {\n              fill: d.color(c.bottom.color).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }],\n              enabled: c.bottom.visible && !c.front.visible\n            }, {\n              fill: d.color(c.bottom.color).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }],\n              enabled: c.bottom.visible && !c.back.visible\n            }]\n          });\n          this.frameShapes.top[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-top\",\n            zIndex: c.top.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }],\n              enabled: c.top.visible\n            }, {\n              fill: d.color(c.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }],\n              enabled: c.top.visible\n            }, {\n              fill: d.color(c.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }],\n              enabled: c.top.visible && !c.left.visible\n            }, {\n              fill: d.color(c.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }],\n              enabled: c.top.visible && !c.right.visible\n            }, {\n              fill: d.color(c.top.color).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }],\n              enabled: c.top.visible && !c.front.visible\n            }, {\n              fill: d.color(c.top.color).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }],\n              enabled: c.top.visible && !c.back.visible\n            }]\n          });\n          this.frameShapes.left[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-left\",\n            zIndex: c.left.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: g,\n                y: q,\n                z: p\n              }],\n              enabled: c.left.visible && !c.bottom.visible\n            }, {\n              fill: d.color(c.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }],\n              enabled: c.left.visible && !c.top.visible\n            }, {\n              fill: d.color(c.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: g,\n                y: q,\n                z: l\n              }],\n              enabled: c.left.visible\n            }, {\n              fill: d.color(c.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: e,\n                y: f,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }],\n              enabled: c.left.visible\n            }, {\n              fill: d.color(c.left.color).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }],\n              enabled: c.left.visible && !c.front.visible\n            }, {\n              fill: d.color(c.left.color).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }],\n              enabled: c.left.visible && !c.back.visible\n            }]\n          });\n          this.frameShapes.right[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-right\",\n            zIndex: c.right.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: m,\n                y: q,\n                z: l\n              }],\n              enabled: c.right.visible && !c.bottom.visible\n            }, {\n              fill: d.color(c.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }],\n              enabled: c.right.visible && !c.top.visible\n            }, {\n              fill: d.color(c.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }],\n              enabled: c.right.visible\n            }, {\n              fill: d.color(c.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: m,\n                y: q,\n                z: p\n              }],\n              enabled: c.right.visible\n            }, {\n              fill: d.color(c.right.color).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }],\n              enabled: c.right.visible && !c.front.visible\n            }, {\n              fill: d.color(c.right.color).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }],\n              enabled: c.right.visible && !c.back.visible\n            }]\n          });\n          this.frameShapes.back[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-back\",\n            zIndex: c.back.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }],\n              enabled: c.back.visible && !c.bottom.visible\n            }, {\n              fill: d.color(c.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }],\n              enabled: c.back.visible && !c.top.visible\n            }, {\n              fill: d.color(c.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: p\n              }, {\n                x: e,\n                y: f,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }],\n              enabled: c.back.visible && !c.left.visible\n            }, {\n              fill: d.color(c.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }],\n              enabled: c.back.visible && !c.right.visible\n            }, {\n              fill: d.color(c.back.color).get(),\n              vertexes: [{\n                x: e,\n                y: f,\n                z: b\n              }, {\n                x: h,\n                y: f,\n                z: b\n              }, {\n                x: h,\n                y: k,\n                z: b\n              }, {\n                x: e,\n                y: k,\n                z: b\n              }],\n              enabled: c.back.visible\n            }, {\n              fill: d.color(c.back.color).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: p\n              }, {\n                x: m,\n                y: q,\n                z: p\n              }, {\n                x: m,\n                y: n,\n                z: p\n              }, {\n                x: g,\n                y: n,\n                z: p\n              }],\n              enabled: c.back.visible\n            }]\n          });\n          this.frameShapes.front[y]({\n            \"class\": \"highcharts-3d-frame highcharts-3d-frame-front\",\n            zIndex: c.front.frontFacing ? -1E3 : 1E3,\n            faces: [{\n              fill: d.color(c.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }],\n              enabled: c.front.visible && !c.bottom.visible\n            }, {\n              fill: d.color(c.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }],\n              enabled: c.front.visible && !c.top.visible\n            }, {\n              fill: d.color(c.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }],\n              enabled: c.front.visible && !c.left.visible\n            }, {\n              fill: d.color(c.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: l\n              }, {\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }],\n              enabled: c.front.visible && !c.right.visible\n            }, {\n              fill: d.color(c.front.color).get(),\n              vertexes: [{\n                x: h,\n                y: f,\n                z: 0\n              }, {\n                x: e,\n                y: f,\n                z: 0\n              }, {\n                x: e,\n                y: k,\n                z: 0\n              }, {\n                x: h,\n                y: k,\n                z: 0\n              }],\n              enabled: c.front.visible\n            }, {\n              fill: d.color(c.front.color).get(),\n              vertexes: [{\n                x: m,\n                y: q,\n                z: l\n              }, {\n                x: g,\n                y: q,\n                z: l\n              }, {\n                x: g,\n                y: n,\n                z: l\n              }, {\n                x: m,\n                y: n,\n                z: l\n              }],\n              enabled: c.front.visible\n            }]\n          });\n        }\n      }\n\n      function h() {\n        this.styledMode && (this.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-3d-top{filter: url(#highcharts-brighter)}\\n.highcharts-3d-side{filter: url(#highcharts-darker)}\\n\"\n        }), [{\n          name: \"darker\",\n          slope: .6\n        }, {\n          name: \"brighter\",\n          slope: 1.4\n        }].forEach(function (a) {\n          this.renderer.definition({\n            tagName: \"filter\",\n            id: \"highcharts-\" + a.name,\n            children: [{\n              tagName: \"feComponentTransfer\",\n              children: [{\n                tagName: \"feFuncR\",\n                type: \"linear\",\n                slope: a.slope\n              }, {\n                tagName: \"feFuncG\",\n                type: \"linear\",\n                slope: a.slope\n              }, {\n                tagName: \"feFuncB\",\n                type: \"linear\",\n                slope: a.slope\n              }]\n            }]\n          });\n        }, this));\n      }\n\n      function k() {\n        var a = this.options;\n        this.is3d() && (a.series || []).forEach(function (c) {\n          \"scatter\" === (c.type || a.chart.type || a.chart.defaultSeriesType) && (c.type = \"scatter3d\");\n        });\n      }\n\n      function n() {\n        var a = this.options.chart.options3d;\n\n        if (this.chart3d && this.is3d()) {\n          a && (a.alpha = a.alpha % 360 + (0 <= a.alpha ? 0 : 360), a.beta = a.beta % 360 + (0 <= a.beta ? 0 : 360));\n          var c = this.inverted,\n              b = this.clipBox,\n              d = this.margin;\n          b[c ? \"y\" : \"x\"] = -(d[3] || 0);\n          b[c ? \"x\" : \"y\"] = -(d[0] || 0);\n          b[c ? \"height\" : \"width\"] = this.chartWidth + (d[3] || 0) + (d[1] || 0);\n          b[c ? \"width\" : \"height\"] = this.chartHeight + (d[0] || 0) + (d[2] || 0);\n          this.scale3d = 1;\n          !0 === a.fitToPlot && (this.scale3d = this.chart3d.getScale(a.depth));\n          this.chart3d.frame3d = this.chart3d.get3dFrame();\n        }\n      }\n\n      function f() {\n        this.is3d() && (this.isDirtyBox = !0);\n      }\n\n      function q() {\n        this.chart3d && this.is3d() && (this.chart3d.frame3d = this.chart3d.get3dFrame());\n      }\n\n      function e() {\n        this.chart3d || (this.chart3d = new L(this));\n      }\n\n      function l(a) {\n        return this.is3d() || a.apply(this, [].slice.call(arguments, 1));\n      }\n\n      function w(a) {\n        var c = this.series.length;\n        if (this.is3d()) for (; c--;) {\n          a = this.series[c], a.translate(), a.render();\n        } else a.call(this);\n      }\n\n      function t(a) {\n        a.apply(this, [].slice.call(arguments, 1));\n        this.is3d() && (this.container.className += \" highcharts-3d-chart\");\n      }\n\n      var L = function () {\n        function a(a) {\n          this.frame3d = void 0;\n          this.chart = a;\n        }\n\n        a.prototype.get3dFrame = function () {\n          var a = this.chart,\n              c = a.options.chart.options3d,\n              b = c.frame,\n              e = a.plotLeft,\n              h = a.plotLeft + a.plotWidth,\n              f = a.plotTop,\n              k = a.plotTop + a.plotHeight,\n              g = c.depth,\n              m = function m(c) {\n            c = d.shapeArea3d(c, a);\n            return .5 < c ? 1 : -.5 > c ? -1 : 0;\n          },\n              n = m([{\n            x: e,\n            y: k,\n            z: g\n          }, {\n            x: h,\n            y: k,\n            z: g\n          }, {\n            x: h,\n            y: k,\n            z: 0\n          }, {\n            x: e,\n            y: k,\n            z: 0\n          }]),\n              q = m([{\n            x: e,\n            y: f,\n            z: 0\n          }, {\n            x: h,\n            y: f,\n            z: 0\n          }, {\n            x: h,\n            y: f,\n            z: g\n          }, {\n            x: e,\n            y: f,\n            z: g\n          }]),\n              l = m([{\n            x: e,\n            y: f,\n            z: 0\n          }, {\n            x: e,\n            y: f,\n            z: g\n          }, {\n            x: e,\n            y: k,\n            z: g\n          }, {\n            x: e,\n            y: k,\n            z: 0\n          }]),\n              r = m([{\n            x: h,\n            y: f,\n            z: g\n          }, {\n            x: h,\n            y: f,\n            z: 0\n          }, {\n            x: h,\n            y: k,\n            z: 0\n          }, {\n            x: h,\n            y: k,\n            z: g\n          }]),\n              x = m([{\n            x: e,\n            y: k,\n            z: 0\n          }, {\n            x: h,\n            y: k,\n            z: 0\n          }, {\n            x: h,\n            y: f,\n            z: 0\n          }, {\n            x: e,\n            y: f,\n            z: 0\n          }]);\n\n          m = m([{\n            x: e,\n            y: f,\n            z: g\n          }, {\n            x: h,\n            y: f,\n            z: g\n          }, {\n            x: h,\n            y: k,\n            z: g\n          }, {\n            x: e,\n            y: k,\n            z: g\n          }]);\n          var u = !1,\n              w = !1,\n              t = !1,\n              D = !1;\n          [].concat(a.xAxis, a.yAxis, a.zAxis).forEach(function (a) {\n            a && (a.horiz ? a.opposite ? w = !0 : u = !0 : a.opposite ? D = !0 : t = !0);\n          });\n\n          var J = function J(a, c, b) {\n            for (var d = [\"size\", \"color\", \"visible\"], e = {}, h = 0; h < d.length; h++) {\n              for (var f = d[h], k = 0; k < a.length; k++) {\n                if (\"object\" === typeof a[k]) {\n                  var g = a[k][f];\n\n                  if (\"undefined\" !== typeof g && null !== g) {\n                    e[f] = g;\n                    break;\n                  }\n                }\n              }\n            }\n\n            a = b;\n            !0 === e.visible || !1 === e.visible ? a = e.visible : \"auto\" === e.visible && (a = 0 < c);\n            return {\n              size: p(e.size, 1),\n              color: p(e.color, \"none\"),\n              frontFacing: 0 < c,\n              visible: a\n            };\n          };\n\n          b = {\n            axes: {},\n            bottom: J([b.bottom, b.top, b], n, u),\n            top: J([b.top, b.bottom, b], q, w),\n            left: J([b.left, b.right, b.side, b], l, t),\n            right: J([b.right, b.left, b.side, b], r, D),\n            back: J([b.back, b.front, b], m, !0),\n            front: J([b.front, b.back, b], x, !1)\n          };\n          \"auto\" === c.axisLabelPosition ? (r = function r(a, c) {\n            return a.visible !== c.visible || a.visible && c.visible && a.frontFacing !== c.frontFacing;\n          }, c = [], r(b.left, b.front) && c.push({\n            y: (f + k) / 2,\n            x: e,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), r(b.left, b.back) && c.push({\n            y: (f + k) / 2,\n            x: e,\n            z: g,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), r(b.right, b.front) && c.push({\n            y: (f + k) / 2,\n            x: h,\n            z: 0,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), r(b.right, b.back) && c.push({\n            y: (f + k) / 2,\n            x: h,\n            z: g,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), n = [], r(b.bottom, b.front) && n.push({\n            x: (e + h) / 2,\n            y: k,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), r(b.bottom, b.back) && n.push({\n            x: (e + h) / 2,\n            y: k,\n            z: g,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), q = [], r(b.top, b.front) && q.push({\n            x: (e + h) / 2,\n            y: f,\n            z: 0,\n            xDir: {\n              x: 1,\n              y: 0,\n              z: 0\n            }\n          }), r(b.top, b.back) && q.push({\n            x: (e + h) / 2,\n            y: f,\n            z: g,\n            xDir: {\n              x: -1,\n              y: 0,\n              z: 0\n            }\n          }), l = [], r(b.bottom, b.left) && l.push({\n            z: (0 + g) / 2,\n            y: k,\n            x: e,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), r(b.bottom, b.right) && l.push({\n            z: (0 + g) / 2,\n            y: k,\n            x: h,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), k = [], r(b.top, b.left) && k.push({\n            z: (0 + g) / 2,\n            y: f,\n            x: e,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: -1\n            }\n          }), r(b.top, b.right) && k.push({\n            z: (0 + g) / 2,\n            y: f,\n            x: h,\n            xDir: {\n              x: 0,\n              y: 0,\n              z: 1\n            }\n          }), e = function e(c, b, d) {\n            if (0 === c.length) return null;\n            if (1 === c.length) return c[0];\n\n            for (var e = 0, h = y(c, a, !1), f = 1; f < h.length; f++) {\n              d * h[f][b] > d * h[e][b] ? e = f : d * h[f][b] === d * h[e][b] && h[f].z < h[e].z && (e = f);\n            }\n\n            return c[e];\n          }, b.axes = {\n            y: {\n              left: e(c, \"x\", -1),\n              right: e(c, \"x\", 1)\n            },\n            x: {\n              top: e(q, \"y\", -1),\n              bottom: e(n, \"y\", 1)\n            },\n            z: {\n              top: e(k, \"y\", -1),\n              bottom: e(l, \"y\", 1)\n            }\n          }) : b.axes = {\n            y: {\n              left: {\n                x: e,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              right: {\n                x: h,\n                z: 0,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              }\n            },\n            x: {\n              top: {\n                y: f,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              bottom: {\n                y: k,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              }\n            },\n            z: {\n              top: {\n                x: t ? h : e,\n                y: f,\n                xDir: t ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              },\n              bottom: {\n                x: t ? h : e,\n                y: k,\n                xDir: t ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              }\n            }\n          };\n          return b;\n        };\n\n        a.prototype.getScale = function (a) {\n          var c = this.chart,\n              b = c.plotLeft,\n              d = c.plotWidth + b,\n              e = c.plotTop,\n              h = c.plotHeight + e,\n              f = b + c.plotWidth / 2,\n              k = e + c.plotHeight / 2,\n              g = Number.MAX_VALUE,\n              m = -Number.MAX_VALUE,\n              n = Number.MAX_VALUE,\n              q = -Number.MAX_VALUE,\n              l = 1;\n          var p = [{\n            x: b,\n            y: e,\n            z: 0\n          }, {\n            x: b,\n            y: e,\n            z: a\n          }];\n          [0, 1].forEach(function (a) {\n            p.push({\n              x: d,\n              y: p[a].y,\n              z: p[a].z\n            });\n          });\n          [0, 1, 2, 3].forEach(function (a) {\n            p.push({\n              x: p[a].x,\n              y: h,\n              z: p[a].z\n            });\n          });\n          p = y(p, c, !1);\n          p.forEach(function (a) {\n            g = Math.min(g, a.x);\n            m = Math.max(m, a.x);\n            n = Math.min(n, a.y);\n            q = Math.max(q, a.y);\n          });\n          b > g && (l = Math.min(l, 1 - Math.abs((b + f) / (g + f)) % 1));\n          d < m && (l = Math.min(l, (d - f) / (m - f)));\n          e > n && (l = 0 > n ? Math.min(l, (e + k) / (-n + e + k)) : Math.min(l, 1 - (e + k) / (n + k) % 1));\n          h < q && (l = Math.min(l, Math.abs((h - k) / (q - k))));\n          return l;\n        };\n\n        return a;\n      }();\n\n      a.Composition = L;\n      a.defaultOptions = {\n        chart: {\n          options3d: {\n            enabled: !1,\n            alpha: 0,\n            beta: 0,\n            depth: 100,\n            fitToPlot: !0,\n            viewDistance: 25,\n            axisLabelPosition: null,\n            frame: {\n              visible: \"default\",\n              size: 1,\n              bottom: {},\n              top: {},\n              left: {},\n              right: {},\n              back: {},\n              front: {}\n            }\n          }\n        }\n      };\n\n      a.compose = function (p, y) {\n        var r = p.prototype;\n        y = y.prototype;\n\n        r.is3d = function () {\n          return this.options.chart.options3d && this.options.chart.options3d.enabled;\n        };\n\n        r.propsRequireDirtyBox.push(\"chart.options3d\");\n        r.propsRequireUpdateSeries.push(\"chart.options3d\");\n\n        y.matrixSetter = function () {\n          if (1 > this.pos && (u(this.start) || u(this.end))) {\n            var a = this.start || [1, 0, 0, 1, 0, 0],\n                c = this.end || [1, 0, 0, 1, 0, 0];\n            var b = [];\n\n            for (var d = 0; 6 > d; d++) {\n              b.push(this.pos * c[d] + (1 - this.pos) * a[d]);\n            }\n          } else b = this.end;\n\n          this.elem.attr(this.prop, b, null, !0);\n        };\n\n        g(!0, D, a.defaultOptions);\n        m(p, \"init\", e);\n        m(p, \"addSeries\", b);\n        m(p, \"afterDrawChartBox\", c);\n        m(p, \"afterGetContainer\", h);\n        m(p, \"afterInit\", k);\n        m(p, \"afterSetChartSize\", n);\n        m(p, \"beforeRedraw\", f);\n        m(p, \"beforeRender\", q);\n        E(d.Chart.prototype, \"isInsidePlot\", l);\n        E(p, \"renderSeries\", w);\n        E(p, \"setClassName\", t);\n      };\n    })(a || (a = {}));\n\n    a.compose(l, w);\n    q.ZChartComposition.compose(l);\n    t.compose(b);\n    \"\";\n    return a;\n  });\n  F(b, \"parts-3d/Series.js\", [b[\"parts/Globals.js\"], b[\"parts/Utilities.js\"]], function (b, t) {\n    var l = t.addEvent,\n        d = t.pick,\n        w = b.perspective;\n    l(b.Series, \"afterTranslate\", function () {\n      this.chart.is3d() && this.translate3dPoints();\n    });\n\n    b.Series.prototype.translate3dPoints = function () {\n      var b = this.chart,\n          l = d(this.zAxis, b.options.zAxis[0]),\n          t = [],\n          m;\n\n      for (m = 0; m < this.data.length; m++) {\n        var u = this.data[m];\n\n        if (l && l.translate) {\n          var g = l.logarithmic && l.val2lin ? l.val2lin(u.z) : u.z;\n          u.plotZ = l.translate(g);\n          u.isInside = u.isInside ? g >= l.min && g <= l.max : !1;\n        } else u.plotZ = 0;\n\n        u.axisXpos = u.plotX;\n        u.axisYpos = u.plotY;\n        u.axisZpos = u.plotZ;\n        t.push({\n          x: u.plotX,\n          y: u.plotY,\n          z: u.plotZ\n        });\n      }\n\n      b = w(t, b, !0);\n\n      for (m = 0; m < this.data.length; m++) {\n        u = this.data[m], l = b[m], u.plotX = l.x, u.plotY = l.y, u.plotZ = l.z;\n      }\n    };\n  });\n  F(b, \"parts-3d/Column.js\", [b[\"parts/Globals.js\"], b[\"parts/Stacking.js\"], b[\"parts/Utilities.js\"]], function (b, t, l) {\n    function d(b, a) {\n      var d = b.series,\n          g = {},\n          c,\n          h = 1;\n      d.forEach(function (b) {\n        c = m(b.options.stack, a ? 0 : d.length - 1 - b.index);\n        g[c] ? g[c].series.push(b) : (g[c] = {\n          series: [b],\n          position: h\n        }, h++);\n      });\n      g.totalStacks = h + 1;\n      return g;\n    }\n\n    function w(b) {\n      var a = b.apply(this, [].slice.call(arguments, 1));\n      this.chart.is3d && this.chart.is3d() && (a.stroke = this.options.edgeColor || a.fill, a[\"stroke-width\"] = m(this.options.edgeWidth, 1));\n      return a;\n    }\n\n    function n(b, a, d) {\n      var k = this.chart.is3d && this.chart.is3d();\n      k && (this.options.inactiveOtherPoints = !0);\n      b.call(this, a, d);\n      k && (this.options.inactiveOtherPoints = !1);\n    }\n\n    function q(b) {\n      for (var a = [], d = 1; d < arguments.length; d++) {\n        a[d - 1] = arguments[d];\n      }\n\n      return this.series.chart.is3d() ? this.graphic && \"g\" !== this.graphic.element.nodeName : b.apply(this, a);\n    }\n\n    var D = l.addEvent,\n        m = l.pick;\n    l = l.wrap;\n    var u = b.perspective,\n        g = b.Series,\n        p = b.seriesTypes,\n        E = b.svg;\n    l(p.column.prototype, \"translate\", function (b) {\n      b.apply(this, [].slice.call(arguments, 1));\n      this.chart.is3d() && this.translate3dShapes();\n    });\n    l(b.Series.prototype, \"justifyDataLabel\", function (b) {\n      return arguments[2].outside3dPlot ? !1 : b.apply(this, [].slice.call(arguments, 1));\n    });\n\n    p.column.prototype.translate3dPoints = function () {};\n\n    p.column.prototype.translate3dShapes = function () {\n      var b = this,\n          a = b.chart,\n          d = b.options,\n          g = d.depth,\n          c = (d.stacking ? d.stack || 0 : b.index) * (g + (d.groupZPadding || 1)),\n          h = b.borderWidth % 2 ? .5 : 0,\n          l;\n      a.inverted && !b.yAxis.reversed && (h *= -1);\n      !1 !== d.grouping && (c = 0);\n      c += d.groupZPadding || 1;\n      b.data.forEach(function (d) {\n        d.outside3dPlot = null;\n\n        if (null !== d.y) {\n          var f = d.shapeArgs,\n              k = d.tooltipPos,\n              e;\n          [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (a) {\n            e = f[a[0]] - h;\n            0 > e && (f[a[1]] += f[a[0]] + h, f[a[0]] = -h, e = 0);\n            e + f[a[1]] > b[a[0] + \"Axis\"].len && 0 !== f[a[1]] && (f[a[1]] = b[a[0] + \"Axis\"].len - f[a[0]]);\n\n            if (0 !== f[a[1]] && (f[a[0]] >= b[a[0] + \"Axis\"].len || f[a[0]] + f[a[1]] <= h)) {\n              for (var c in f) {\n                f[c] = 0;\n              }\n\n              d.outside3dPlot = !0;\n            }\n          });\n          \"rect\" === d.shapeType && (d.shapeType = \"cuboid\");\n          f.z = c;\n          f.depth = g;\n          f.insidePlotArea = !0;\n          l = {\n            x: f.x + f.width / 2,\n            y: f.y,\n            z: c + g / 2\n          };\n          a.inverted && (l.x = f.height, l.y = d.clientX);\n          d.plot3d = u([l], a, !0, !1)[0];\n          k = u([{\n            x: k[0],\n            y: k[1],\n            z: c + g / 2\n          }], a, !0, !1)[0];\n          d.tooltipPos = [k.x, k.y];\n        }\n      });\n      b.z = c;\n    };\n\n    l(p.column.prototype, \"animate\", function (b) {\n      if (this.chart.is3d()) {\n        var a = arguments[1],\n            d = this.yAxis,\n            g = this,\n            c = this.yAxis.reversed;\n        E && (a ? g.data.forEach(function (a) {\n          null !== a.y && (a.height = a.shapeArgs.height, a.shapey = a.shapeArgs.y, a.shapeArgs.height = 1, c || (a.shapeArgs.y = a.stackY ? a.plotY + d.translate(a.stackY) : a.plotY + (a.negative ? -a.height : a.height)));\n        }) : (g.data.forEach(function (a) {\n          null !== a.y && (a.shapeArgs.height = a.height, a.shapeArgs.y = a.shapey, a.graphic && a.graphic.animate(a.shapeArgs, g.options.animation));\n        }), this.drawDataLabels()));\n      } else b.apply(this, [].slice.call(arguments, 1));\n    });\n    l(p.column.prototype, \"plotGroup\", function (b, a, d, g, c, h) {\n      \"dataLabelsGroup\" !== a && this.chart.is3d() && (this[a] && delete this[a], h && (this.chart.columnGroup || (this.chart.columnGroup = this.chart.renderer.g(\"columnGroup\").add(h)), this[a] = this.chart.columnGroup, this.chart.columnGroup.attr(this.getPlotBox()), this[a].survive = !0, \"group\" === a || \"markerGroup\" === a)) && (arguments[3] = \"visible\");\n      return b.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n    l(p.column.prototype, \"setVisible\", function (b, a) {\n      var d = this,\n          g;\n      d.chart.is3d() && d.data.forEach(function (b) {\n        g = (b.visible = b.options.visible = a = \"undefined\" === typeof a ? !m(d.visible, b.visible) : a) ? \"visible\" : \"hidden\";\n        d.options.data[d.data.indexOf(b)] = b.options;\n        b.graphic && b.graphic.attr({\n          visibility: g\n        });\n      });\n      b.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n    p.column.prototype.handle3dGrouping = !0;\n    D(g, \"afterInit\", function () {\n      if (this.chart.is3d() && this.handle3dGrouping) {\n        var b = this.options,\n            a = b.grouping,\n            g = b.stacking,\n            l = m(this.yAxis.options.reversedStacks, !0),\n            c = 0;\n\n        if (\"undefined\" === typeof a || a) {\n          a = d(this.chart, g);\n          c = b.stack || 0;\n\n          for (g = 0; g < a[c].series.length && a[c].series[g] !== this; g++) {\n            ;\n          }\n\n          c = 10 * (a.totalStacks - a[c].position) + (l ? g : -g);\n          this.xAxis.reversed || (c = 10 * a.totalStacks - c);\n        }\n\n        b.depth = b.depth || 25;\n        this.z = this.z || 0;\n        b.zIndex = c;\n      }\n    });\n    l(p.column.prototype, \"pointAttribs\", w);\n    l(p.column.prototype, \"setState\", n);\n    l(p.column.prototype.pointClass.prototype, \"hasNewShapeType\", q);\n    p.columnrange && (l(p.columnrange.prototype, \"pointAttribs\", w), l(p.columnrange.prototype, \"setState\", n), l(p.columnrange.prototype.pointClass.prototype, \"hasNewShapeType\", q), p.columnrange.prototype.plotGroup = p.column.prototype.plotGroup, p.columnrange.prototype.setVisible = p.column.prototype.setVisible);\n    l(g.prototype, \"alignDataLabel\", function (b, a, d, g, c) {\n      var h = this.chart;\n      g.outside3dPlot = a.outside3dPlot;\n\n      if (h.is3d() && this.is(\"column\")) {\n        var k = this.options,\n            l = m(g.inside, !!this.options.stacking),\n            f = h.options.chart.options3d,\n            n = a.pointWidth / 2 || 0;\n        k = {\n          x: c.x + n,\n          y: c.y,\n          z: this.z + k.depth / 2\n        };\n        h.inverted && (l && (c.width = 0, k.x += a.shapeArgs.height / 2), 90 <= f.alpha && 270 >= f.alpha && (k.y += a.shapeArgs.width));\n        k = u([k], h, !0, !1)[0];\n        c.x = k.x - n;\n        c.y = a.outside3dPlot ? -9E9 : k.y;\n      }\n\n      b.apply(this, [].slice.call(arguments, 1));\n    });\n    l(t.prototype, \"getStackBox\", function (b, a, d, g, c, h, l, m) {\n      var f = b.apply(this, [].slice.call(arguments, 1));\n\n      if (a.is3d() && d.base) {\n        var k = +d.base.split(\",\")[0],\n            e = a.series[k];\n        k = a.options.chart.options3d;\n        e && e instanceof p.column && (e = {\n          x: f.x + (a.inverted ? l : h / 2),\n          y: f.y,\n          z: e.options.depth / 2\n        }, a.inverted && (f.width = 0, 90 <= k.alpha && 270 >= k.alpha && (e.y += h)), e = u([e], a, !0, !1)[0], f.x = e.x - h / 2, f.y = e.y);\n      }\n\n      return f;\n    });\n  });\n  F(b, \"parts-3d/Pie.js\", [b[\"parts/Globals.js\"], b[\"parts/Utilities.js\"]], function (b, t) {\n    var l = t.pick;\n    t = t.wrap;\n    var d = b.deg2rad,\n        w = b.seriesTypes,\n        n = b.svg;\n    t(w.pie.prototype, \"translate\", function (b) {\n      b.apply(this, [].slice.call(arguments, 1));\n\n      if (this.chart.is3d()) {\n        var l = this,\n            m = l.options,\n            n = m.depth || 0,\n            g = l.chart.options.chart.options3d,\n            p = g.alpha,\n            q = g.beta,\n            t = m.stacking ? (m.stack || 0) * n : l._i * n;\n        t += n / 2;\n        !1 !== m.grouping && (t = 0);\n        l.data.forEach(function (a) {\n          var b = a.shapeArgs;\n          a.shapeType = \"arc3d\";\n          b.z = t;\n          b.depth = .75 * n;\n          b.alpha = p;\n          b.beta = q;\n          b.center = l.center;\n          b = (b.end + b.start) / 2;\n          a.slicedTranslation = {\n            translateX: Math.round(Math.cos(b) * m.slicedOffset * Math.cos(p * d)),\n            translateY: Math.round(Math.sin(b) * m.slicedOffset * Math.cos(p * d))\n          };\n        });\n      }\n    });\n    t(w.pie.prototype.pointClass.prototype, \"haloPath\", function (b) {\n      var d = arguments;\n      return this.series.chart.is3d() ? [] : b.call(this, d[1]);\n    });\n    t(w.pie.prototype, \"pointAttribs\", function (b, d, m) {\n      b = b.call(this, d, m);\n      m = this.options;\n      this.chart.is3d() && !this.chart.styledMode && (b.stroke = m.edgeColor || d.color || this.color, b[\"stroke-width\"] = l(m.edgeWidth, 1));\n      return b;\n    });\n    t(w.pie.prototype, \"drawDataLabels\", function (b) {\n      if (this.chart.is3d()) {\n        var l = this.chart.options.chart.options3d;\n        this.data.forEach(function (b) {\n          var m = b.shapeArgs,\n              g = m.r,\n              n = (m.start + m.end) / 2;\n          b = b.labelPosition;\n          var q = b.connectorPosition,\n              t = -g * (1 - Math.cos((m.alpha || l.alpha) * d)) * Math.sin(n),\n              a = g * (Math.cos((m.beta || l.beta) * d) - 1) * Math.cos(n);\n          [b.natural, q.breakAt, q.touchingSliceAt].forEach(function (b) {\n            b.x += a;\n            b.y += t;\n          });\n        });\n      }\n\n      b.apply(this, [].slice.call(arguments, 1));\n    });\n    t(w.pie.prototype, \"addPoint\", function (b) {\n      b.apply(this, [].slice.call(arguments, 1));\n      this.chart.is3d() && this.update(this.userOptions, !0);\n    });\n    t(w.pie.prototype, \"animate\", function (b) {\n      if (this.chart.is3d()) {\n        var d = arguments[1],\n            m = this.options.animation,\n            q = this.center,\n            g = this.group,\n            p = this.markerGroup;\n        n && (!0 === m && (m = {}), d ? (g.oldtranslateX = l(g.oldtranslateX, g.translateX), g.oldtranslateY = l(g.oldtranslateY, g.translateY), d = {\n          translateX: q[0],\n          translateY: q[1],\n          scaleX: .001,\n          scaleY: .001\n        }, g.attr(d), p && (p.attrSetters = g.attrSetters, p.attr(d))) : (d = {\n          translateX: g.oldtranslateX,\n          translateY: g.oldtranslateY,\n          scaleX: 1,\n          scaleY: 1\n        }, g.animate(d, m), p && p.animate(d, m)));\n      } else b.apply(this, [].slice.call(arguments, 1));\n    });\n  });\n  F(b, \"parts-3d/Scatter.js\", [b[\"parts/Globals.js\"], b[\"parts/Point.js\"], b[\"parts/Utilities.js\"]], function (b, t, l) {\n    l = l.seriesType;\n    var d = b.seriesTypes;\n    l(\"scatter3d\", \"scatter\", {\n      tooltip: {\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>\"\n      }\n    }, {\n      pointAttribs: function pointAttribs(l) {\n        var n = d.scatter.prototype.pointAttribs.apply(this, arguments);\n        this.chart.is3d() && l && (n.zIndex = b.pointCameraDistance(l, this.chart));\n        return n;\n      },\n      axisTypes: [\"xAxis\", \"yAxis\", \"zAxis\"],\n      pointArrayMap: [\"x\", \"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      directTouch: !0\n    }, {\n      applyOptions: function applyOptions() {\n        t.prototype.applyOptions.apply(this, arguments);\n        \"undefined\" === typeof this.z && (this.z = 0);\n        return this;\n      }\n    });\n    \"\";\n  });\n  F(b, \"parts-3d/VMLAxis3D.js\", [b[\"parts/Utilities.js\"]], function (b) {\n    var t = b.addEvent,\n        l = function () {\n      return function (b) {\n        this.axis = b;\n      };\n    }();\n\n    return function () {\n      function b() {}\n\n      b.compose = function (d) {\n        d.keepProps.push(\"vml\");\n        t(d, \"init\", b.onInit);\n        t(d, \"render\", b.onRender);\n      };\n\n      b.onInit = function () {\n        this.vml || (this.vml = new l(this));\n      };\n\n      b.onRender = function () {\n        var b = this.vml;\n        b.sideFrame && (b.sideFrame.css({\n          zIndex: 0\n        }), b.sideFrame.front.attr({\n          fill: b.sideFrame.color\n        }));\n        b.bottomFrame && (b.bottomFrame.css({\n          zIndex: 1\n        }), b.bottomFrame.front.attr({\n          fill: b.bottomFrame.color\n        }));\n        b.backFrame && (b.backFrame.css({\n          zIndex: 0\n        }), b.backFrame.front.attr({\n          fill: b.backFrame.color\n        }));\n      };\n\n      return b;\n    }();\n  });\n  F(b, \"parts-3d/VMLRenderer.js\", [b[\"parts/Axis.js\"], b[\"parts/Globals.js\"], b[\"parts/SVGRenderer.js\"], b[\"parts/Utilities.js\"], b[\"parts-3d/VMLAxis3D.js\"]], function (b, t, l, d, w) {\n    d = d.setOptions;\n    var n = t.VMLRenderer;\n    n && (d({\n      animate: !1\n    }), n.prototype.face3d = l.prototype.face3d, n.prototype.polyhedron = l.prototype.polyhedron, n.prototype.elements3d = l.prototype.elements3d, n.prototype.element3d = l.prototype.element3d, n.prototype.cuboid = l.prototype.cuboid, n.prototype.cuboidPath = l.prototype.cuboidPath, n.prototype.toLinePath = l.prototype.toLinePath, n.prototype.toLineSegments = l.prototype.toLineSegments, n.prototype.arc3d = function (b) {\n      b = l.prototype.arc3d.call(this, b);\n      b.css({\n        zIndex: b.zIndex\n      });\n      return b;\n    }, t.VMLRenderer.prototype.arc3dPath = l.prototype.arc3dPath, w.compose(b));\n  });\n  F(b, \"masters/highcharts-3d.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}