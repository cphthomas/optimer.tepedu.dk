{"ast":null,"code":"/*global require*/\nvar Tableau = require(\"./Tableau.js\");\n\nvar SlackVariable = require(\"../expressions.js\").SlackVariable;\n\nTableau.prototype.addCutConstraints = function (cutConstraints) {\n  var nCutConstraints = cutConstraints.length;\n  var height = this.height;\n  var heightWithCuts = height + nCutConstraints; // Adding rows to hold cut constraints\n\n  for (var h = height; h < heightWithCuts; h += 1) {\n    if (this.matrix[h] === undefined) {\n      this.matrix[h] = this.matrix[h - 1].slice();\n    }\n  } // Adding cut constraints\n\n\n  this.height = heightWithCuts;\n  this.nVars = this.width + this.height - 2;\n  var c;\n  var lastColumn = this.width - 1;\n\n  for (var i = 0; i < nCutConstraints; i += 1) {\n    var cut = cutConstraints[i]; // Constraint row index\n\n    var r = height + i;\n    var sign = cut.type === \"min\" ? -1 : 1; // Variable on which the cut is applied\n\n    var varIndex = cut.varIndex;\n    var varRowIndex = this.rowByVarIndex[varIndex];\n    var constraintRow = this.matrix[r];\n\n    if (varRowIndex === -1) {\n      // Variable is non basic\n      constraintRow[this.rhsColumn] = sign * cut.value;\n\n      for (c = 1; c <= lastColumn; c += 1) {\n        constraintRow[c] = 0;\n      }\n\n      constraintRow[this.colByVarIndex[varIndex]] = sign;\n    } else {\n      // Variable is basic\n      var varRow = this.matrix[varRowIndex];\n      var varValue = varRow[this.rhsColumn];\n      constraintRow[this.rhsColumn] = sign * (cut.value - varValue);\n\n      for (c = 1; c <= lastColumn; c += 1) {\n        constraintRow[c] = -sign * varRow[c];\n      }\n    } // Creating slack variable\n\n\n    var slackVarIndex = this.getNewElementIndex();\n    this.varIndexByRow[r] = slackVarIndex;\n    this.rowByVarIndex[slackVarIndex] = r;\n    this.colByVarIndex[slackVarIndex] = -1;\n    this.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\" + slackVarIndex, slackVarIndex);\n    this.nVars += 1;\n  }\n};\n\nTableau.prototype._addLowerBoundMIRCut = function (rowIndex) {\n  if (rowIndex === this.costRowIndex) {\n    //console.log(\"! IN MIR CUTS : The index of the row corresponds to the cost row. !\");\n    return false;\n  }\n\n  var model = this.model;\n  var matrix = this.matrix;\n  var intVar = this.variablesPerIndex[this.varIndexByRow[rowIndex]];\n\n  if (!intVar.isInteger) {\n    return false;\n  }\n\n  var d = matrix[rowIndex][this.rhsColumn];\n  var frac_d = d - Math.floor(d);\n\n  if (frac_d < this.precision || 1 - this.precision < frac_d) {\n    return false;\n  } //Adding a row\n\n\n  var r = this.height;\n  matrix[r] = matrix[r - 1].slice();\n  this.height += 1; // Creating slack variable\n\n  this.nVars += 1;\n  var slackVarIndex = this.getNewElementIndex();\n  this.varIndexByRow[r] = slackVarIndex;\n  this.rowByVarIndex[slackVarIndex] = r;\n  this.colByVarIndex[slackVarIndex] = -1;\n  this.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\" + slackVarIndex, slackVarIndex);\n  matrix[r][this.rhsColumn] = Math.floor(d);\n\n  for (var colIndex = 1; colIndex < this.varIndexByCol.length; colIndex += 1) {\n    var variable = this.variablesPerIndex[this.varIndexByCol[colIndex]];\n\n    if (!variable.isInteger) {\n      matrix[r][colIndex] = Math.min(0, matrix[rowIndex][colIndex] / (1 - frac_d));\n    } else {\n      var coef = matrix[rowIndex][colIndex];\n      var termCoeff = Math.floor(coef) + Math.max(0, coef - Math.floor(coef) - frac_d) / (1 - frac_d);\n      matrix[r][colIndex] = termCoeff;\n    }\n  }\n\n  for (var c = 0; c < this.width; c += 1) {\n    matrix[r][c] -= matrix[rowIndex][c];\n  }\n\n  return true;\n};\n\nTableau.prototype._addUpperBoundMIRCut = function (rowIndex) {\n  if (rowIndex === this.costRowIndex) {\n    //console.log(\"! IN MIR CUTS : The index of the row corresponds to the cost row. !\");\n    return false;\n  }\n\n  var model = this.model;\n  var matrix = this.matrix;\n  var intVar = this.variablesPerIndex[this.varIndexByRow[rowIndex]];\n\n  if (!intVar.isInteger) {\n    return false;\n  }\n\n  var b = matrix[rowIndex][this.rhsColumn];\n  var f = b - Math.floor(b);\n\n  if (f < this.precision || 1 - this.precision < f) {\n    return false;\n  } //Adding a row\n\n\n  var r = this.height;\n  matrix[r] = matrix[r - 1].slice();\n  this.height += 1; // Creating slack variable\n\n  this.nVars += 1;\n  var slackVarIndex = this.getNewElementIndex();\n  this.varIndexByRow[r] = slackVarIndex;\n  this.rowByVarIndex[slackVarIndex] = r;\n  this.colByVarIndex[slackVarIndex] = -1;\n  this.variablesPerIndex[slackVarIndex] = new SlackVariable(\"s\" + slackVarIndex, slackVarIndex);\n  matrix[r][this.rhsColumn] = -f;\n\n  for (var colIndex = 1; colIndex < this.varIndexByCol.length; colIndex += 1) {\n    var variable = this.variablesPerIndex[this.varIndexByCol[colIndex]];\n    var aj = matrix[rowIndex][colIndex];\n    var fj = aj - Math.floor(aj);\n\n    if (variable.isInteger) {\n      if (fj <= f) {\n        matrix[r][colIndex] = -fj;\n      } else {\n        matrix[r][colIndex] = -(1 - fj) * f / fj;\n      }\n    } else {\n      if (aj >= 0) {\n        matrix[r][colIndex] = -aj;\n      } else {\n        matrix[r][colIndex] = aj * f / (1 - f);\n      }\n    }\n  }\n\n  return true;\n}; //\n// THIS MAKES SOME MILP PROBLEMS PROVIDE INCORRECT\n// ANSWERS...\n//\n// QUICK FIX: MAKE THE FUNCTION EMPTY...\n//\n\n\nTableau.prototype.applyMIRCuts = function () {// var nRows = this.height;\n  // for (var cst = 0; cst < nRows; cst += 1) {\n  //    this._addUpperBoundMIRCut(cst);\n  // }\n  // // nRows = tableau.height;\n  // for (cst = 0; cst < nRows; cst += 1) {\n  //    this._addLowerBoundMIRCut(cst);\n  // }\n};","map":null,"metadata":{},"sourceType":"script"}