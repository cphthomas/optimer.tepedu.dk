{"ast":null,"code":"/*global describe*/\n\n/*global require*/\n\n/*global module*/\n\n/*global it*/\n\n/*global console*/\n\n/*global process*/\n\n/*jshint -W083 */\n\n/*************************************************************\r\n* Method: to_JSON\r\n* Scope: Public:\r\n* Agruments: input: Whatever the user gives us\r\n* Purpose: Convert an unfriendly formatted LP\r\n*          into something that our library can\r\n*          work with\r\n**************************************************************/\nfunction to_JSON(input) {\n  var rxo = {\n    /* jshint ignore:start */\n    \"is_blank\": /^\\W{0,}$/,\n    \"is_objective\": /(max|min)(imize){0,}\\:/i,\n    \"is_int\": /^(?!\\/\\*)\\W{0,}int/i,\n    \"is_bin\": /^(?!\\/\\*)\\W{0,}bin/i,\n    \"is_constraint\": /(\\>|\\<){0,}\\=/i,\n    \"is_unrestricted\": /^\\S{0,}unrestricted/i,\n    \"parse_lhs\": /(\\-|\\+){0,1}\\s{0,1}\\d{0,}\\.{0,}\\d{0,}\\s{0,}[A-Za-z]\\S{0,}/gi,\n    \"parse_rhs\": /(\\-|\\+){0,1}\\d{1,}\\.{0,}\\d{0,}\\W{0,}\\;{0,1}$/i,\n    \"parse_dir\": /(\\>|\\<){0,}\\=/gi,\n    \"parse_int\": /[^\\s|^\\,]+/gi,\n    \"parse_bin\": /[^\\s|^\\,]+/gi,\n    \"get_num\": /(\\-|\\+){0,1}(\\W|^)\\d+\\.{0,1}\\d{0,}/g,\n    \"get_word\": /[A-Za-z].*/\n    /* jshint ignore:end */\n\n  },\n      model = {\n    \"opType\": \"\",\n    \"optimize\": \"_obj\",\n    \"constraints\": {},\n    \"variables\": {}\n  },\n      constraints = {\n    \">=\": \"min\",\n    \"<=\": \"max\",\n    \"=\": \"equal\"\n  },\n      tmp = \"\",\n      tst = 0,\n      ary = null,\n      hldr = \"\",\n      hldr2 = \"\",\n      constraint = \"\",\n      rhs = 0; // Handle input if its coming\n  // to us as a hard string\n  // instead of as an array of\n  // strings\n\n  if (typeof input === \"string\") {\n    input = input.split(\"\\n\");\n  } // Start iterating over the rows\n  // to see what all we have\n\n\n  for (var i = 0; i < input.length; i++) {\n    constraint = \"__\" + i; // Get the string we're working with\n\n    tmp = input[i]; // Set the test = 0\n\n    tst = 0; // Reset the array\n\n    ary = null; // Test to see if we're the objective\n\n    if (rxo.is_objective.test(tmp)) {\n      // Set up in model the opType\n      model.opType = tmp.match(/(max|min)/gi)[0]; // Pull apart lhs\n\n      ary = tmp.match(rxo.parse_lhs).map(function (d) {\n        return d.replace(/\\s+/, \"\");\n      }).slice(1); // *** STEP 1 *** ///\n      // Get the variables out\n\n      ary.forEach(function (d) {\n        // Get the number if its there\n        hldr = d.match(rxo.get_num); // If it isn't a number, it might\n        // be a standalone variable\n\n        if (hldr === null) {\n          if (d.substr(0, 1) === \"-\") {\n            hldr = -1;\n          } else {\n            hldr = 1;\n          }\n        } else {\n          hldr = hldr[0];\n        }\n\n        hldr = parseFloat(hldr); // Get the variable type\n\n        hldr2 = d.match(rxo.get_word)[0].replace(/\\;$/, \"\"); // Make sure the variable is in the model\n\n        model.variables[hldr2] = model.variables[hldr2] || {};\n        model.variables[hldr2]._obj = hldr;\n      }); ////////////////////////////////////\n    } else if (rxo.is_int.test(tmp)) {\n      // Get the array of ints\n      ary = tmp.match(rxo.parse_int).slice(1); // Since we have an int, our model should too\n\n      model.ints = model.ints || {};\n      ary.forEach(function (d) {\n        d = d.replace(\";\", \"\");\n        model.ints[d] = 1;\n      }); ////////////////////////////////////\n    } else if (rxo.is_bin.test(tmp)) {\n      // Get the array of bins\n      ary = tmp.match(rxo.parse_bin).slice(1); // Since we have an binary, our model should too\n\n      model.binaries = model.binaries || {};\n      ary.forEach(function (d) {\n        d = d.replace(\";\", \"\");\n        model.binaries[d] = 1;\n      }); ////////////////////////////////////\n    } else if (rxo.is_constraint.test(tmp)) {\n      var separatorIndex = tmp.indexOf(\":\");\n      var constraintExpression = separatorIndex === -1 ? tmp : tmp.slice(separatorIndex + 1); // Pull apart lhs\n\n      ary = constraintExpression.match(rxo.parse_lhs).map(function (d) {\n        return d.replace(/\\s+/, \"\");\n      }); // *** STEP 1 *** ///\n      // Get the variables out\n\n      ary.forEach(function (d) {\n        // Get the number if its there\n        hldr = d.match(rxo.get_num);\n\n        if (hldr === null) {\n          if (d.substr(0, 1) === \"-\") {\n            hldr = -1;\n          } else {\n            hldr = 1;\n          }\n        } else {\n          hldr = hldr[0];\n        }\n\n        hldr = parseFloat(hldr); // Get the variable name\n\n        hldr2 = d.match(rxo.get_word)[0]; // Make sure the variable is in the model\n\n        model.variables[hldr2] = model.variables[hldr2] || {};\n        model.variables[hldr2][constraint] = hldr;\n      }); // *** STEP 2 *** ///\n      // Get the RHS out\n\n      rhs = parseFloat(tmp.match(rxo.parse_rhs)[0]); // *** STEP 3 *** ///\n      // Get the Constrainer out\n\n      tmp = constraints[tmp.match(rxo.parse_dir)[0]];\n      model.constraints[constraint] = model.constraints[constraint] || {};\n      model.constraints[constraint][tmp] = rhs; ////////////////////////////////////\n    } else if (rxo.is_unrestricted.test(tmp)) {\n      // Get the array of unrestricted\n      ary = tmp.match(rxo.parse_int).slice(1); // Since we have an int, our model should too\n\n      model.unrestricted = model.unrestricted || {};\n      ary.forEach(function (d) {\n        d = d.replace(\";\", \"\");\n        model.unrestricted[d] = 1;\n      });\n    }\n  }\n\n  return model;\n}\n/*************************************************************\r\n* Method: from_JSON\r\n* Scope: Public:\r\n* Agruments: model: The model we want solver to operate on\r\n* Purpose: Convert a friendly JSON model into a model for a\r\n*          real solving library...in this case\r\n*          lp_solver\r\n**************************************************************/\n\n\nfunction from_JSON(model) {\n  // Make sure we at least have a model\n  if (!model) {\n    throw new Error(\"Solver requires a model to operate on\");\n  }\n\n  var output = \"\",\n      ary = [],\n      norm = 1,\n      lookup = {\n    \"max\": \"<=\",\n    \"min\": \">=\",\n    \"equal\": \"=\"\n  },\n      rxClean = new RegExp(\"[^A-Za-z0-9_\\[\\{\\}\\/\\.\\&\\#\\$\\%\\~\\'\\@\\^]\", \"gi\"); // Build the objective statement\n\n  if (model.opType) {\n    output += model.opType + \":\"; // Iterate over the variables\n\n    for (var x in model.variables) {\n      // Give each variable a self of 1 unless\n      // it exists already\n      model.variables[x][x] = model.variables[x][x] ? model.variables[x][x] : 1; // Does our objective exist here?\n\n      if (model.variables[x][model.optimize]) {\n        output += \" \" + model.variables[x][model.optimize] + \" \" + x.replace(rxClean, \"_\");\n      }\n    }\n  } else {\n    output += \"max:\";\n  } // Add some closure to our line thing\n\n\n  output += \";\\n\\n\"; // And now... to iterate over the constraints\n\n  for (var xx in model.constraints) {\n    for (var y in model.constraints[xx]) {\n      if (typeof lookup[y] !== \"undefined\") {\n        for (var z in model.variables) {\n          // Does our Constraint exist here?\n          if (typeof model.variables[z][xx] !== \"undefined\") {\n            output += \" \" + model.variables[z][xx] + \" \" + z.replace(rxClean, \"_\");\n          }\n        } // Add the constraint type and value...\n\n\n        output += \" \" + lookup[y] + \" \" + model.constraints[xx][y];\n        output += \";\\n\";\n      }\n    }\n  } // Are there any ints?\n\n\n  if (model.ints) {\n    output += \"\\n\\n\";\n\n    for (var xxx in model.ints) {\n      output += \"int \" + xxx.replace(rxClean, \"_\") + \";\\n\";\n    }\n  } // Are there any unrestricted?\n\n\n  if (model.unrestricted) {\n    output += \"\\n\\n\";\n\n    for (var xxxx in model.unrestricted) {\n      output += \"unrestricted \" + xxxx.replace(rxClean, \"_\") + \";\\n\";\n    }\n  } // And kick the string back\n\n\n  return output;\n}\n\nmodule.exports = function (model) {\n  // If the user is giving us an array\n  // or a string, convert it to a JSON Model\n  // otherwise, spit it out as a string\n  if (model.length) {\n    return to_JSON(model);\n  } else {\n    return from_JSON(model);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}