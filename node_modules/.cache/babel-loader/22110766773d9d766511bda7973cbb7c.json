{"ast":null,"code":"/*\n Highcharts JS v8.1.2 (2020-06-16)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (f) {\n  \"object\" === typeof module && module.exports ? (f[\"default\"] = f, module.exports = f) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (C) {\n    f(C);\n    f.Highcharts = C;\n    return f;\n  }) : f(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (f) {\n  function C(f, a, b, e) {\n    f.hasOwnProperty(a) || (f[a] = e.apply(null, b));\n  }\n\n  f = f ? f._modules : {};\n  C(f, \"parts-more/Pane.js\", [f[\"parts/Chart.js\"], f[\"parts/Globals.js\"], f[\"parts/Pointer.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e) {\n    function h(l, c, p) {\n      return Math.sqrt(Math.pow(l - p[0], 2) + Math.pow(c - p[1], 2)) < p[2] / 2;\n    }\n\n    var q = e.addEvent,\n        t = e.extend,\n        x = e.merge,\n        B = e.pick,\n        z = e.splat,\n        c = a.CenteredSeriesMixin;\n    f.prototype.collectionsWithUpdate.push(\"pane\");\n\n    e = function () {\n      function l(l, c) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(l, c);\n      }\n\n      l.prototype.init = function (l, c) {\n        this.chart = c;\n        this.background = [];\n        c.pane.push(this);\n        this.setOptions(l);\n      };\n\n      l.prototype.setOptions = function (l) {\n        this.options = x(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, l);\n      };\n\n      l.prototype.render = function () {\n        var l = this.options,\n            c = this.options.background,\n            a = this.chart.renderer;\n        this.group || (this.group = a.g(\"pane-group\").attr({\n          zIndex: l.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (c) for (c = z(c), l = Math.max(c.length, this.background.length || 0), a = 0; a < l; a++) {\n          c[a] && this.axis ? this.renderBackground(x(this.defaultBackgroundOptions, c[a]), a) : this.background[a] && (this.background[a] = this.background[a].destroy(), this.background.splice(a, 1));\n        }\n      };\n\n      l.prototype.renderBackground = function (l, c) {\n        var a = \"animate\",\n            p = {\n          \"class\": \"highcharts-pane \" + (l.className || \"\")\n        };\n        this.chart.styledMode || t(p, {\n          fill: l.backgroundColor,\n          stroke: l.borderColor,\n          \"stroke-width\": l.borderWidth\n        });\n        this.background[c] || (this.background[c] = this.chart.renderer.path().add(this.group), a = \"attr\");\n        this.background[c][a]({\n          d: this.axis.getPlotBandPath(l.from, l.to, l)\n        }).attr(p);\n      };\n\n      l.prototype.updateCenter = function (l) {\n        this.center = (l || this.axis || {}).center = c.getCenter.call(this);\n      };\n\n      l.prototype.update = function (l, c) {\n        x(!0, this.options, l);\n        x(!0, this.chart.options.pane, l);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (l) {\n          l.pane === this && (l.pane = null, l.update({}, c));\n        }, this);\n      };\n\n      return l;\n    }();\n\n    a.Chart.prototype.getHoverPane = function (l) {\n      var c = this,\n          a;\n      l && c.pane.forEach(function (p) {\n        var e = l.chartX - c.plotLeft,\n            m = l.chartY - c.plotTop;\n        h(c.inverted ? m : e, c.inverted ? e : m, p.center) && (a = p);\n      });\n      return a;\n    };\n\n    q(f, \"afterIsInsidePlot\", function (l) {\n      this.polar && (l.isInsidePlot = this.pane.some(function (c) {\n        return h(l.x, l.y, c.center);\n      }));\n    });\n    q(b, \"beforeGetHoverData\", function (l) {\n      var c = this.chart;\n      c.polar && (c.hoverPane = c.getHoverPane(l), l.filter = function (a) {\n        return a.visible && !(!l.shared && a.directTouch) && B(a.options.enableMouseTracking, !0) && (!c.hoverPane || a.xAxis.pane === c.hoverPane);\n      });\n    });\n    q(b, \"afterGetHoverData\", function (c) {\n      var l = this.chart;\n      c.hoverPoint && c.hoverPoint.plotX && c.hoverPoint.plotY && l.hoverPane && !h(c.hoverPoint.plotX, c.hoverPoint.plotY, l.hoverPane.center) && (c.hoverPoint = void 0);\n    });\n    a.Pane = e;\n    return a.Pane;\n  });\n  C(f, \"parts-more/HiddenAxis.js\", [], function () {\n    return function () {\n      function f() {}\n\n      f.init = function (a) {\n        a.getOffset = function () {};\n\n        a.redraw = function () {\n          this.isDirty = !1;\n        };\n\n        a.render = function () {\n          this.isDirty = !1;\n        };\n\n        a.createLabelCollector = function () {\n          return function () {};\n        };\n\n        a.setScale = function () {};\n\n        a.setCategories = function () {};\n\n        a.setTitle = function () {};\n\n        a.isHidden = !0;\n      };\n\n      return f;\n    }();\n  });\n  C(f, \"parts-more/RadialAxis.js\", [f[\"parts/Axis.js\"], f[\"parts/Tick.js\"], f[\"parts-more/HiddenAxis.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e) {\n    var h = e.addEvent,\n        q = e.correctFloat,\n        t = e.defined,\n        x = e.extend,\n        B = e.fireEvent,\n        z = e.merge,\n        c = e.pick,\n        l = e.relativeLength,\n        w = e.wrap;\n\n    e = function () {\n      function a() {}\n\n      a.init = function (a) {\n        var h = f.prototype;\n\n        a.setOptions = function (m) {\n          m = this.options = z(a.constructor.defaultOptions, this.defaultPolarOptions, m);\n          m.plotBands || (m.plotBands = []);\n          B(this, \"afterSetOptions\");\n        };\n\n        a.getOffset = function () {\n          h.getOffset.call(this);\n          this.chart.axisOffset[this.side] = 0;\n        };\n\n        a.getLinePath = function (m, n, d) {\n          m = this.pane.center;\n          var g = this.chart,\n              k = c(n, m[2] / 2 - this.offset);\n          \"undefined\" === typeof d && (d = this.horiz ? 0 : this.center && -this.center[3] / 2);\n          d && (k += d);\n          this.isCircular || \"undefined\" !== typeof n ? (n = this.chart.renderer.symbols.arc(this.left + m[0], this.top + m[1], k, k, {\n            start: this.startAngleRad,\n            end: this.endAngleRad,\n            open: !0,\n            innerR: 0\n          }), n.xBounds = [this.left + m[0]], n.yBounds = [this.top + m[1] - k]) : (n = this.postTranslate(this.angleRad, k), n = [[\"M\", this.center[0] + g.plotLeft, this.center[1] + g.plotTop], [\"L\", n.x, n.y]]);\n          return n;\n        };\n\n        a.setAxisTranslation = function () {\n          h.setAxisTranslation.call(this);\n          this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n        };\n\n        a.beforeSetTickPositions = function () {\n          this.autoConnect = this.isCircular && \"undefined\" === typeof c(this.userMax, this.options.max) && q(this.endAngleRad - this.startAngleRad) === q(2 * Math.PI);\n          !this.isCircular && this.chart.inverted && this.max++;\n          this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n        };\n\n        a.setAxisSize = function () {\n          h.setAxisSize.call(this);\n\n          if (this.isRadial) {\n            this.pane.updateCenter(this);\n            var m = this.center = x([], this.pane.center);\n            if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n              var n = this.postTranslate(this.angleRad, m[3] / 2);\n              m[0] = n.x - this.chart.plotLeft;\n              m[1] = n.y - this.chart.plotTop;\n            }\n            this.len = this.width = this.height = (m[2] - m[3]) * c(this.sector, 1) / 2;\n          }\n        };\n\n        a.getPosition = function (m, n) {\n          m = this.translate(m);\n          return this.postTranslate(this.isCircular ? m : this.angleRad, c(this.isCircular ? n : 0 > m ? 0 : m, this.center[2] / 2) - this.offset);\n        };\n\n        a.postTranslate = function (m, n) {\n          var d = this.chart,\n              g = this.center;\n          m = this.startAngleRad + m;\n          return {\n            x: d.plotLeft + g[0] + Math.cos(m) * n,\n            y: d.plotTop + g[1] + Math.sin(m) * n\n          };\n        };\n\n        a.getPlotBandPath = function (m, n, d) {\n          var g = function g(d) {\n            if (\"string\" === typeof d) {\n              var g = parseInt(d, 10);\n              D.test(d) && (g = g * A / 100);\n              return g;\n            }\n\n            return d;\n          },\n              k = this.center,\n              u = this.startAngleRad,\n              A = k[2] / 2,\n              r = Math.min(this.offset, 0),\n              D = /%$/;\n\n          var l = this.isCircular;\n          var a = c(g(d.outerRadius), A),\n              h = g(d.innerRadius);\n          g = c(g(d.thickness), 10);\n          if (\"polygon\" === this.options.gridLineInterpolation) r = this.getPlotLinePath({\n            value: m\n          }).concat(this.getPlotLinePath({\n            value: n,\n            reverse: !0\n          }));else {\n            m = Math.max(m, this.min);\n            n = Math.min(n, this.max);\n            m = this.translate(m);\n            n = this.translate(n);\n            l || (a = m || 0, h = n || 0);\n            if (\"circle\" !== d.shape && l) d = u + (m || 0), u += n || 0;else {\n              d = -Math.PI / 2;\n              u = 1.5 * Math.PI;\n              var p = !0;\n            }\n            a -= r;\n            r = this.chart.renderer.symbols.arc(this.left + k[0], this.top + k[1], a, a, {\n              start: Math.min(d, u),\n              end: Math.max(d, u),\n              innerR: c(h, a - (g - r)),\n              open: p\n            });\n            l && (l = (u + d) / 2, p = this.left + k[0] + k[2] / 2 * Math.cos(l), r.xBounds = l > -Math.PI / 2 && l < Math.PI / 2 ? [p, this.chart.plotWidth] : [0, p], r.yBounds = [this.top + k[1] + k[2] / 2 * Math.sin(l)], r.yBounds[0] += l > -Math.PI && 0 > l || l > Math.PI ? -10 : 10);\n          }\n          return r;\n        };\n\n        a.getCrosshairPosition = function (m, n, d) {\n          var g = m.value,\n              k = this.pane.center;\n\n          if (this.isCircular) {\n            if (t(g)) m.point && (u = m.point.shapeArgs || {}, u.start && (g = this.chart.inverted ? this.translate(m.point.rectPlotY, !0) : m.point.x));else {\n              var u = m.chartX || 0;\n              var A = m.chartY || 0;\n              g = this.translate(Math.atan2(A - d, u - n) - this.startAngleRad, !0);\n            }\n            m = this.getPosition(g);\n            u = m.x;\n            A = m.y;\n          } else t(g) || (u = m.chartX, A = m.chartY), t(u) && t(A) && (d = k[1] + this.chart.plotTop, g = this.translate(Math.min(Math.sqrt(Math.pow(u - n, 2) + Math.pow(A - d, 2)), k[2] / 2) - k[3] / 2, !0));\n\n          return [g, u || 0, A || 0];\n        };\n\n        a.getPlotLinePath = function (m) {\n          var n = this,\n              d = n.pane.center,\n              g = n.chart,\n              k = g.inverted,\n              u = m.value,\n              A = m.reverse,\n              r = n.getPosition(u),\n              c = n.pane.options.background ? n.pane.options.background[0] || n.pane.options.background : {},\n              a = c.innerRadius || \"0%\",\n              h = c.outerRadius || \"100%\";\n          c = d[0] + g.plotLeft;\n          var p = d[1] + g.plotTop,\n              e = r.x,\n              b = r.y,\n              w = n.height;\n          r = d[3] / 2;\n          var q;\n          m.isCrosshair && (b = this.getCrosshairPosition(m, c, p), u = b[0], e = b[1], b = b[2]);\n          if (n.isCircular) u = Math.sqrt(Math.pow(e - c, 2) + Math.pow(b - p, 2)), A = \"string\" === typeof a ? l(a, 1) : a / u, g = \"string\" === typeof h ? l(h, 1) : h / u, d && r && (u = r / u, A < u && (A = u), g < u && (g = u)), d = [[\"M\", c + A * (e - c), p - A * (p - b)], [\"L\", e - (1 - g) * (e - c), b + (1 - g) * (p - b)]];else if ((u = n.translate(u)) && (0 > u || u > w) && (u = 0), \"circle\" === n.options.gridLineInterpolation) d = n.getLinePath(0, u, r);else if (d = [], g[k ? \"yAxis\" : \"xAxis\"].forEach(function (d) {\n            d.pane === n.pane && (q = d);\n          }), q) for (c = q.tickPositions, q.autoConnect && (c = c.concat([c[0]])), A && (c = c.slice().reverse()), u && (u += r), e = 0; e < c.length; e++) {\n            p = q.getPosition(c[e], u), d.push(e ? [\"L\", p.x, p.y] : [\"M\", p.x, p.y]);\n          }\n          return d;\n        };\n\n        a.getTitlePosition = function () {\n          var c = this.center,\n              n = this.chart,\n              d = this.options.title;\n          return {\n            x: n.plotLeft + c[0] + (d.x || 0),\n            y: n.plotTop + c[1] - {\n              high: .5,\n              middle: .25,\n              low: 0\n            }[d.align] * c[2] + (d.y || 0)\n          };\n        };\n\n        a.createLabelCollector = function () {\n          var c = this;\n          return function () {\n            if (c.isRadial && c.tickPositions && !0 !== c.options.labels.allowOverlap) return c.tickPositions.map(function (n) {\n              return c.ticks[n] && c.ticks[n].label;\n            }).filter(function (n) {\n              return !!n;\n            });\n          };\n        };\n      };\n\n      a.compose = function (p, e) {\n        h(p, \"init\", function (c) {\n          var n = this.chart,\n              d = n.inverted,\n              g = n.angular,\n              k = n.polar,\n              u = this.isXAxis,\n              A = this.coll,\n              r = g && u,\n              l,\n              m = n.options;\n          c = c.userOptions.pane || 0;\n          c = this.pane = n.pane && n.pane[c];\n          if (\"colorAxis\" === A) this.isRadial = !1;else {\n            if (g) {\n              if (r ? b.init(this) : a.init(this), l = !u) this.defaultPolarOptions = a.defaultRadialGaugeOptions;\n            } else k && (a.init(this), this.defaultPolarOptions = (l = this.horiz) ? a.defaultCircularOptions : z(\"xAxis\" === A ? p.defaultOptions : p.defaultYAxisOptions, a.defaultRadialOptions), d && \"yAxis\" === A && (this.defaultPolarOptions.stackLabels = p.defaultYAxisOptions.stackLabels));\n\n            g || k ? (this.isRadial = !0, m.chart.zoomType = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && n.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n            c && l && (c.axis = this);\n            this.isCircular = l;\n          }\n        });\n        h(p, \"afterInit\", function () {\n          var l = this.chart,\n              n = this.options,\n              d = this.pane,\n              g = d && d.options;\n          l.angular && this.isXAxis || !d || !l.angular && !l.polar || (this.angleRad = (n.angle || 0) * Math.PI / 180, this.startAngleRad = (g.startAngle - 90) * Math.PI / 180, this.endAngleRad = (c(g.endAngle, g.startAngle + 360) - 90) * Math.PI / 180, this.offset = n.offset || 0);\n        });\n        h(p, \"autoLabelAlign\", function (c) {\n          this.isRadial && (c.align = void 0, c.preventDefault());\n        });\n        h(p, \"destroy\", function () {\n          if (this.chart && this.chart.labelCollectors) {\n            var c = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n            0 <= c && this.chart.labelCollectors.splice(c, 1);\n          }\n        });\n        h(p, \"initialAxisTranslation\", function () {\n          this.isRadial && this.beforeSetTickPositions();\n        });\n        h(e, \"afterGetPosition\", function (c) {\n          this.axis.getPosition && x(c.pos, this.axis.getPosition(this.pos));\n        });\n        h(e, \"afterGetLabelPosition\", function (a) {\n          var n = this.axis,\n              d = this.label;\n\n          if (d) {\n            var g = d.getBBox(),\n                k = n.options.labels,\n                u = k.y,\n                A = 20,\n                r = k.align,\n                m = (n.translate(this.pos) + n.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n                p = Math.round(m),\n                h = \"end\",\n                e = 0 > p ? p + 360 : p,\n                b = e,\n                w = 0,\n                q = 0,\n                v = null === k.y ? .3 * -g.height : 0;\n\n            if (n.isRadial) {\n              var y = n.getPosition(this.pos, n.center[2] / 2 + l(c(k.distance, -25), n.center[2] / 2, -n.center[2] / 2));\n              \"auto\" === k.rotation ? d.attr({\n                rotation: m\n              }) : null === u && (u = n.chart.renderer.fontMetrics(d.styles && d.styles.fontSize).b - g.height / 2);\n              null === r && (n.isCircular ? (g.width > n.len * n.tickInterval / (n.max - n.min) && (A = 0), r = m > A && m < 180 - A ? \"left\" : m > 180 + A && m < 360 - A ? \"right\" : \"center\") : r = \"center\", d.attr({\n                align: r\n              }));\n\n              if (\"auto\" === r && 2 === n.tickPositions.length && n.isCircular) {\n                90 < e && 180 > e ? e = 180 - e : 270 < e && 360 >= e && (e = 540 - e);\n                180 < b && 360 >= b && (b = 360 - b);\n                if (n.pane.options.startAngle === p || n.pane.options.startAngle === p + 360 || n.pane.options.startAngle === p - 360) h = \"start\";\n                r = -90 <= p && 90 >= p || -360 <= p && -270 >= p || 270 <= p && 360 >= p ? \"start\" === h ? \"right\" : \"left\" : \"start\" === h ? \"left\" : \"right\";\n                70 < b && 110 > b && (r = \"center\");\n                15 > e || 180 <= e && 195 > e ? w = .3 * g.height : 15 <= e && 35 >= e ? w = \"start\" === h ? 0 : .75 * g.height : 195 <= e && 215 >= e ? w = \"start\" === h ? .75 * g.height : 0 : 35 < e && 90 >= e ? w = \"start\" === h ? .25 * -g.height : g.height : 215 < e && 270 >= e && (w = \"start\" === h ? g.height : .25 * -g.height);\n                15 > b ? q = \"start\" === h ? .15 * -g.height : .15 * g.height : 165 < b && 180 >= b && (q = \"start\" === h ? .15 * g.height : .15 * -g.height);\n                d.attr({\n                  align: r\n                });\n                d.translate(q, w + v);\n              }\n\n              a.pos.x = y.x + k.x;\n              a.pos.y = y.y + u;\n            }\n          }\n        });\n        w(e.prototype, \"getMarkPath\", function (c, n, d, g, k, u, A) {\n          var r = this.axis;\n          r.isRadial ? (c = r.getPosition(this.pos, r.center[2] / 2 + g), n = [\"M\", n, d, \"L\", c.x, c.y]) : n = c.call(this, n, d, g, k, u, A);\n          return n;\n        });\n      };\n\n      a.defaultCircularOptions = {\n        gridLineWidth: 1,\n        labels: {\n          align: null,\n          distance: 15,\n          x: 0,\n          y: null,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      };\n      a.defaultRadialGaugeOptions = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: null\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      };\n      a.defaultRadialOptions = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n      return a;\n    }();\n\n    e.compose(f, a);\n    return e;\n  });\n  C(f, \"parts-more/AreaRangeSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Point.js\"], f[\"parts/Utilities.js\"]], function (f, a, b) {\n    var e = b.defined,\n        h = b.extend,\n        q = b.isArray,\n        t = b.isNumber,\n        x = b.pick;\n    b = b.seriesType;\n    var B = f.seriesTypes,\n        z = f.Series.prototype,\n        c = a.prototype;\n    b(\"arearange\", \"area\", {\n      lineWidth: 1,\n      threshold: null,\n      tooltip: {\n        pointFormat: \"<span style=\\\"color:{series.color}\\\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>\"\n      },\n      trackByArea: !0,\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        xLow: 0,\n        xHigh: 0,\n        yLow: 0,\n        yHigh: 0\n      }\n    }, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"low\",\n      deferTranslatePolar: !0,\n      toYData: function toYData(c) {\n        return [c.low, c.high];\n      },\n      highToXY: function highToXY(c) {\n        var l = this.chart,\n            a = this.xAxis.postTranslate(c.rectPlotX, this.yAxis.len - c.plotHigh);\n        c.plotHighX = a.x - l.plotLeft;\n        c.plotHigh = a.y - l.plotTop;\n        c.plotLowX = c.plotX;\n      },\n      translate: function translate() {\n        var c = this,\n            a = c.yAxis,\n            p = !!c.modifyValue;\n        B.area.prototype.translate.apply(c);\n        c.points.forEach(function (l) {\n          var e = l.high,\n              m = l.plotY;\n          l.isNull ? l.plotY = null : (l.plotLow = m, l.plotHigh = a.translate(p ? c.modifyValue(e, l) : e, 0, 1, 0, 1), p && (l.yBottom = l.plotHigh));\n        });\n        this.chart.polar && this.points.forEach(function (l) {\n          c.highToXY(l);\n          l.tooltipPos = [(l.plotHighX + l.plotLowX) / 2, (l.plotHigh + l.plotLow) / 2];\n        });\n      },\n      getGraphPath: function getGraphPath(c) {\n        var a = [],\n            l = [],\n            e,\n            h = B.area.prototype.getGraphPath;\n        var m = this.options;\n        var n = this.chart.polar && !1 !== m.connectEnds,\n            d = m.connectNulls,\n            g = m.step;\n        c = c || this.points;\n\n        for (e = c.length; e--;) {\n          var k = c[e];\n          k.isNull || n || d || c[e + 1] && !c[e + 1].isNull || l.push({\n            plotX: k.plotX,\n            plotY: k.plotY,\n            doCurve: !1\n          });\n          var u = {\n            polarPlotY: k.polarPlotY,\n            rectPlotX: k.rectPlotX,\n            yBottom: k.yBottom,\n            plotX: x(k.plotHighX, k.plotX),\n            plotY: k.plotHigh,\n            isNull: k.isNull\n          };\n          l.push(u);\n          a.push(u);\n          k.isNull || n || d || c[e - 1] && !c[e - 1].isNull || l.push({\n            plotX: k.plotX,\n            plotY: k.plotY,\n            doCurve: !1\n          });\n        }\n\n        c = h.call(this, c);\n        g && (!0 === g && (g = \"left\"), m.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[g]);\n        a = h.call(this, a);\n        l = h.call(this, l);\n        m.step = g;\n        m = [].concat(c, a);\n        !this.chart.polar && l[0] && \"M\" === l[0][0] && (l[0] = [\"L\", l[0][1], l[0][2]]);\n        this.graphPath = m;\n        this.areaPath = c.concat(l);\n        m.isArea = !0;\n        m.xMap = c.xMap;\n        this.areaPath.xMap = c.xMap;\n        return m;\n      },\n      drawDataLabels: function drawDataLabels() {\n        var c = this.points,\n            a = c.length,\n            e,\n            b = [],\n            f = this.options.dataLabels,\n            m,\n            n = this.chart.inverted;\n        if (q(f)) {\n          if (1 < f.length) {\n            var d = f[0];\n            var g = f[1];\n          } else d = f[0], g = {\n            enabled: !1\n          };\n        } else d = h({}, f), d.x = f.xHigh, d.y = f.yHigh, g = h({}, f), g.x = f.xLow, g.y = f.yLow;\n\n        if (d.enabled || this._hasPointLabels) {\n          for (e = a; e--;) {\n            if (m = c[e]) {\n              var k = d.inside ? m.plotHigh < m.plotLow : m.plotHigh > m.plotLow;\n              m.y = m.high;\n              m._plotY = m.plotY;\n              m.plotY = m.plotHigh;\n              b[e] = m.dataLabel;\n              m.dataLabel = m.dataLabelUpper;\n              m.below = k;\n              n ? d.align || (d.align = k ? \"right\" : \"left\") : d.verticalAlign || (d.verticalAlign = k ? \"top\" : \"bottom\");\n            }\n          }\n\n          this.options.dataLabels = d;\n          z.drawDataLabels && z.drawDataLabels.apply(this, arguments);\n\n          for (e = a; e--;) {\n            if (m = c[e]) m.dataLabelUpper = m.dataLabel, m.dataLabel = b[e], delete m.dataLabels, m.y = m.low, m.plotY = m._plotY;\n          }\n        }\n\n        if (g.enabled || this._hasPointLabels) {\n          for (e = a; e--;) {\n            if (m = c[e]) k = g.inside ? m.plotHigh < m.plotLow : m.plotHigh > m.plotLow, m.below = !k, n ? g.align || (g.align = k ? \"left\" : \"right\") : g.verticalAlign || (g.verticalAlign = k ? \"bottom\" : \"top\");\n          }\n\n          this.options.dataLabels = g;\n          z.drawDataLabels && z.drawDataLabels.apply(this, arguments);\n        }\n\n        if (d.enabled) for (e = a; e--;) {\n          if (m = c[e]) m.dataLabels = [m.dataLabelUpper, m.dataLabel].filter(function (d) {\n            return !!d;\n          });\n        }\n        this.options.dataLabels = f;\n      },\n      alignDataLabel: function alignDataLabel() {\n        B.column.prototype.alignDataLabel.apply(this, arguments);\n      },\n      drawPoints: function drawPoints() {\n        var c = this.points.length,\n            a;\n        z.drawPoints.apply(this, arguments);\n\n        for (a = 0; a < c;) {\n          var b = this.points[a];\n          b.origProps = {\n            plotY: b.plotY,\n            plotX: b.plotX,\n            isInside: b.isInside,\n            negative: b.negative,\n            zone: b.zone,\n            y: b.y\n          };\n          b.lowerGraphic = b.graphic;\n          b.graphic = b.upperGraphic;\n          b.plotY = b.plotHigh;\n          e(b.plotHighX) && (b.plotX = b.plotHighX);\n          b.y = b.high;\n          b.negative = b.high < (this.options.threshold || 0);\n          b.zone = this.zones.length && b.getZone();\n          this.chart.polar || (b.isInside = b.isTopInside = \"undefined\" !== typeof b.plotY && 0 <= b.plotY && b.plotY <= this.yAxis.len && 0 <= b.plotX && b.plotX <= this.xAxis.len);\n          a++;\n        }\n\n        z.drawPoints.apply(this, arguments);\n\n        for (a = 0; a < c;) {\n          b = this.points[a], b.upperGraphic = b.graphic, b.graphic = b.lowerGraphic, h(b, b.origProps), delete b.origProps, a++;\n        }\n      },\n      setStackedPoints: f.noop\n    }, {\n      setState: function setState() {\n        var a = this.state,\n            b = this.series,\n            h = b.chart.polar;\n        e(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0));\n        e(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0));\n        b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic);\n        this.graphic = this.upperGraphic;\n        this.plotY = this.plotHigh;\n        h && (this.plotX = this.plotHighX);\n        c.setState.apply(this, arguments);\n        this.state = a;\n        this.plotY = this.plotLow;\n        this.graphic = this.lowerGraphic;\n        h && (this.plotX = this.plotLowX);\n        b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0);\n        c.setState.apply(this, arguments);\n      },\n      haloPath: function haloPath() {\n        var a = this.series.chart.polar,\n            b = [];\n        this.plotY = this.plotLow;\n        a && (this.plotX = this.plotLowX);\n        this.isInside && (b = c.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        a && (this.plotX = this.plotHighX);\n        this.isTopInside && (b = b.concat(c.haloPath.apply(this, arguments)));\n        return b;\n      },\n      destroyElements: function destroyElements() {\n        [\"lowerGraphic\", \"upperGraphic\"].forEach(function (c) {\n          this[c] && (this[c] = this[c].destroy());\n        }, this);\n        this.graphic = null;\n        return c.destroyElements.apply(this, arguments);\n      },\n      isValid: function isValid() {\n        return t(this.low) && t(this.high);\n      }\n    });\n    \"\";\n  });\n  C(f, \"parts-more/AreaSplineRangeSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    a = a.seriesType;\n    a(\"areasplinerange\", \"arearange\", null, {\n      getPointSpline: f.seriesTypes.spline.prototype.getPointSpline\n    });\n    \"\";\n  });\n  C(f, \"parts-more/ColumnRangeSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Options.js\"], f[\"parts/Utilities.js\"]], function (f, a, b) {\n    a = a.defaultOptions;\n    var e = b.clamp,\n        h = b.merge,\n        q = b.pick;\n    b = b.seriesType;\n    var t = f.noop,\n        x = f.seriesTypes.column.prototype;\n    b(\"columnrange\", \"arearange\", h(a.plotOptions.column, a.plotOptions.arearange, {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    }), {\n      translate: function translate() {\n        var a = this,\n            b = a.yAxis,\n            c = a.xAxis,\n            l = c.startAngleRad,\n            h,\n            p = a.chart,\n            f = a.xAxis.isRadial,\n            t = Math.max(p.chartWidth, p.chartHeight) + 999,\n            m;\n        x.translate.apply(a);\n        a.points.forEach(function (n) {\n          var d = n.shapeArgs,\n              g = a.options.minPointLength;\n          n.plotHigh = m = e(b.translate(n.high, 0, 1, 0, 1), -t, t);\n          n.plotLow = e(n.plotY, -t, t);\n          var k = m;\n          var u = q(n.rectPlotY, n.plotY) - m;\n          Math.abs(u) < g ? (g -= u, u += g, k -= g / 2) : 0 > u && (u *= -1, k -= u);\n          f ? (h = n.barX + l, n.shapeType = \"arc\", n.shapeArgs = a.polarArc(k + u, k, h, h + n.pointWidth)) : (d.height = u, d.y = k, n.tooltipPos = p.inverted ? [b.len + b.pos - p.plotLeft - k - u / 2, c.len + c.pos - p.plotTop - d.x - d.width / 2, u] : [c.left - p.plotLeft + d.x + d.width / 2, b.pos - p.plotTop + k + u / 2, u]);\n        });\n      },\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      drawGraph: t,\n      getSymbol: t,\n      crispCol: function crispCol() {\n        return x.crispCol.apply(this, arguments);\n      },\n      drawPoints: function drawPoints() {\n        return x.drawPoints.apply(this, arguments);\n      },\n      drawTracker: function drawTracker() {\n        return x.drawTracker.apply(this, arguments);\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        return x.getColumnMetrics.apply(this, arguments);\n      },\n      pointAttribs: function pointAttribs() {\n        return x.pointAttribs.apply(this, arguments);\n      },\n      animate: function animate() {\n        return x.animate.apply(this, arguments);\n      },\n      polarArc: function polarArc() {\n        return x.polarArc.apply(this, arguments);\n      },\n      translate3dPoints: function translate3dPoints() {\n        return x.translate3dPoints.apply(this, arguments);\n      },\n      translate3dShapes: function translate3dShapes() {\n        return x.translate3dShapes.apply(this, arguments);\n      }\n    }, {\n      setState: x.pointClass.prototype.setState\n    });\n    \"\";\n  });\n  C(f, \"parts-more/ColumnPyramidSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    var b = a.clamp,\n        e = a.pick;\n    a = a.seriesType;\n    var h = f.seriesTypes.column.prototype;\n    a(\"columnpyramid\", \"column\", {}, {\n      translate: function translate() {\n        var a = this,\n            f = a.chart,\n            x = a.options,\n            B = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        B = a.borderWidth = e(x.borderWidth, B ? 0 : 1);\n        var z = a.yAxis,\n            c = x.threshold,\n            l = a.translatedThreshold = z.getThreshold(c),\n            w = e(x.minPointLength, 5),\n            p = a.getColumnMetrics(),\n            y = p.width,\n            v = a.barW = Math.max(y, 1 + 2 * B),\n            m = a.pointXOffset = p.offset;\n        f.inverted && (l -= .5);\n        x.pointPadding && (v = Math.ceil(v));\n        h.translate.apply(a);\n        a.points.forEach(function (n) {\n          var d = e(n.yBottom, l),\n              g = 999 + Math.abs(d),\n              k = b(n.plotY, -g, z.len + g);\n          g = n.plotX + m;\n          var u = v / 2,\n              A = Math.min(k, d);\n          d = Math.max(k, d) - A;\n          var r;\n          n.barX = g;\n          n.pointWidth = y;\n          n.tooltipPos = f.inverted ? [z.len + z.pos - f.plotLeft - k, a.xAxis.len - g - u, d] : [g + u, k + z.pos - f.plotTop, d];\n          k = c + (n.total || n.y);\n          \"percent\" === x.stacking && (k = c + (0 > n.y) ? -100 : 100);\n          k = z.toPixels(k, !0);\n          var D = (r = f.plotHeight - k - (f.plotHeight - l)) ? u * (A - k) / r : 0;\n          var h = r ? u * (A + d - k) / r : 0;\n          r = g - D + u;\n          D = g + D + u;\n          var p = g + h + u;\n          h = g - h + u;\n          var q = A - w;\n          var E = A + d;\n          0 > n.y && (q = A, E = A + d + w);\n          f.inverted && (p = f.plotWidth - A, r = k - (f.plotWidth - l), D = u * (k - p) / r, h = u * (k - (p - d)) / r, r = g + u + D, D = r - 2 * D, p = g - h + u, h = g + h + u, q = A, E = A + d - w, 0 > n.y && (E = A + d + w));\n          n.shapeType = \"path\";\n          n.shapeArgs = {\n            x: r,\n            y: q,\n            width: D - r,\n            height: d,\n            d: [[\"M\", r, q], [\"L\", D, q], [\"L\", p, E], [\"L\", h, E], [\"Z\"]]\n          };\n        });\n      }\n    });\n    \"\";\n  });\n  C(f, \"parts-more/GaugeSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    var b = a.clamp,\n        e = a.isNumber,\n        h = a.merge,\n        q = a.pick,\n        t = a.pInt;\n    a = a.seriesType;\n    var x = f.Series,\n        B = f.TrackerMixin;\n    a(\"gauge\", \"line\", {\n      dataLabels: {\n        borderColor: \"#cccccc\",\n        borderRadius: 3,\n        borderWidth: 1,\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        verticalAlign: \"top\",\n        y: 15,\n        zIndex: 2\n      },\n      dial: {},\n      pivot: {},\n      tooltip: {\n        headerFormat: \"\"\n      },\n      showInLegend: !1\n    }, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: f.noop,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      translate: function translate() {\n        var a = this.yAxis,\n            c = this.options,\n            l = a.center;\n        this.generatePoints();\n        this.points.forEach(function (f) {\n          var p = h(c.dial, f.dial),\n              w = t(q(p.radius, \"80%\")) * l[2] / 200,\n              v = t(q(p.baseLength, \"70%\")) * w / 100,\n              m = t(q(p.rearLength, \"10%\")) * w / 100,\n              n = p.baseWidth || 3,\n              d = p.topWidth || 1,\n              g = c.overshoot,\n              k = a.startAngleRad + a.translate(f.y, null, null, null, !0);\n          if (e(g) || !1 === c.wrap) g = e(g) ? g / 180 * Math.PI : 0, k = b(k, a.startAngleRad - g, a.endAngleRad + g);\n          k = 180 * k / Math.PI;\n          f.shapeType = \"path\";\n          f.shapeArgs = {\n            d: p.path || [[\"M\", -m, -n / 2], [\"L\", v, -n / 2], [\"L\", w, -d / 2], [\"L\", w, d / 2], [\"L\", v, n / 2], [\"L\", -m, n / 2], [\"Z\"]],\n            translateX: l[0],\n            translateY: l[1],\n            rotation: k\n          };\n          f.plotX = l[0];\n          f.plotY = l[1];\n        });\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = a.chart,\n            b = a.yAxis.center,\n            e = a.pivot,\n            f = a.options,\n            t = f.pivot,\n            v = c.renderer;\n        a.points.forEach(function (b) {\n          var n = b.graphic,\n              d = b.shapeArgs,\n              g = d.d,\n              k = h(f.dial, b.dial);\n          n ? (n.animate(d), d.d = g) : b.graphic = v[b.shapeType](d).attr({\n            rotation: d.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!c.styledMode) b.graphic[n ? \"animate\" : \"attr\"]({\n            stroke: k.borderColor || \"none\",\n            \"stroke-width\": k.borderWidth || 0,\n            fill: k.backgroundColor || \"#000000\"\n          });\n        });\n        e ? e.animate({\n          translateX: b[0],\n          translateY: b[1]\n        }) : (a.pivot = v.circle(0, 0, q(t.radius, 5)).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(b[0], b[1]).add(a.group), c.styledMode || a.pivot.attr({\n          \"stroke-width\": t.borderWidth || 0,\n          stroke: t.borderColor || \"#cccccc\",\n          fill: t.backgroundColor || \"#000000\"\n        }));\n      },\n      animate: function animate(a) {\n        var c = this;\n        a || c.points.forEach(function (a) {\n          var b = a.graphic;\n          b && (b.attr({\n            rotation: 180 * c.yAxis.startAngleRad / Math.PI\n          }), b.animate({\n            rotation: a.shapeArgs.rotation\n          }, c.options.animation));\n        });\n      },\n      render: function render() {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"visible\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        x.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      },\n      setData: function setData(a, c) {\n        x.prototype.setData.call(this, a, !1);\n        this.processData();\n        this.generatePoints();\n        q(c, !0) && this.chart.redraw();\n      },\n      hasData: function hasData() {\n        return !!this.points.length;\n      },\n      drawTracker: B && B.drawTrackerPoint\n    }, {\n      setState: function setState(a) {\n        this.state = a;\n      }\n    });\n    \"\";\n  });\n  C(f, \"parts-more/BoxPlotSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    var b = a.pick;\n    a = a.seriesType;\n    var e = f.noop,\n        h = f.seriesTypes;\n    a(\"boxplot\", \"column\", {\n      threshold: null,\n      tooltip: {\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>\"\n      },\n      whiskerLength: \"50%\",\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      medianWidth: 2,\n      whiskerWidth: 2\n    }, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      toYData: function toYData(a) {\n        return [a.low, a.q1, a.median, a.q3, a.high];\n      },\n      pointValKey: \"high\",\n      pointAttribs: function pointAttribs() {\n        return {};\n      },\n      drawDataLabels: e,\n      translate: function translate() {\n        var a = this.yAxis,\n            b = this.pointArrayMap;\n        h.column.prototype.translate.apply(this);\n        this.points.forEach(function (e) {\n          b.forEach(function (b) {\n            null !== e[b] && (e[b + \"Plot\"] = a.translate(e[b], 0, 1, 0, 1));\n          });\n          e.plotHigh = e.highPlot;\n        });\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            e = a.options,\n            h = a.chart,\n            f = h.renderer,\n            z,\n            c,\n            l,\n            w,\n            p,\n            y,\n            v = 0,\n            m,\n            n,\n            d,\n            g,\n            k = !1 !== a.doQuartiles,\n            u,\n            A = a.options.whiskerLength;\n        a.points.forEach(function (r) {\n          var D = r.graphic,\n              I = D ? \"animate\" : \"attr\",\n              q = r.shapeArgs,\n              G = {},\n              E = {},\n              F = {},\n              H = {},\n              t = r.color || a.color;\n          \"undefined\" !== typeof r.plotY && (m = Math.round(q.width), n = Math.floor(q.x), d = n + m, g = Math.round(m / 2), z = Math.floor(k ? r.q1Plot : r.lowPlot), c = Math.floor(k ? r.q3Plot : r.lowPlot), l = Math.floor(r.highPlot), w = Math.floor(r.lowPlot), D || (r.graphic = D = f.g(\"point\").add(a.group), r.stem = f.path().addClass(\"highcharts-boxplot-stem\").add(D), A && (r.whiskers = f.path().addClass(\"highcharts-boxplot-whisker\").add(D)), k && (r.box = f.path(void 0).addClass(\"highcharts-boxplot-box\").add(D)), r.medianShape = f.path(void 0).addClass(\"highcharts-boxplot-median\").add(D)), h.styledMode || (E.stroke = r.stemColor || e.stemColor || t, E[\"stroke-width\"] = b(r.stemWidth, e.stemWidth, e.lineWidth), E.dashstyle = r.stemDashStyle || e.stemDashStyle || e.dashStyle, r.stem.attr(E), A && (F.stroke = r.whiskerColor || e.whiskerColor || t, F[\"stroke-width\"] = b(r.whiskerWidth, e.whiskerWidth, e.lineWidth), F.dashstyle = r.whiskerDashStyle || e.whiskerDashStyle || e.dashStyle, r.whiskers.attr(F)), k && (G.fill = r.fillColor || e.fillColor || t, G.stroke = e.lineColor || t, G[\"stroke-width\"] = e.lineWidth || 0, G.dashstyle = r.boxDashStyle || e.boxDashStyle || e.dashStyle, r.box.attr(G)), H.stroke = r.medianColor || e.medianColor || t, H[\"stroke-width\"] = b(r.medianWidth, e.medianWidth, e.lineWidth), H.dashstyle = r.medianDashStyle || e.medianDashStyle || e.dashStyle, r.medianShape.attr(H)), y = r.stem.strokeWidth() % 2 / 2, v = n + g + y, D = [[\"M\", v, c], [\"L\", v, l], [\"M\", v, z], [\"L\", v, w]], r.stem[I]({\n            d: D\n          }), k && (y = r.box.strokeWidth() % 2 / 2, z = Math.floor(z) + y, c = Math.floor(c) + y, n += y, d += y, D = [[\"M\", n, c], [\"L\", n, z], [\"L\", d, z], [\"L\", d, c], [\"L\", n, c], [\"Z\"]], r.box[I]({\n            d: D\n          })), A && (y = r.whiskers.strokeWidth() % 2 / 2, l += y, w += y, u = /%$/.test(A) ? g * parseFloat(A) / 100 : A / 2, D = [[\"M\", v - u, l], [\"L\", v + u, l], [\"M\", v - u, w], [\"L\", v + u, w]], r.whiskers[I]({\n            d: D\n          })), p = Math.round(r.medianPlot), y = r.medianShape.strokeWidth() % 2 / 2, p += y, D = [[\"M\", n, p], [\"L\", d, p]], r.medianShape[I]({\n            d: D\n          }));\n        });\n      },\n      setStackedPoints: e\n    });\n    \"\";\n  });\n  C(f, \"parts-more/ErrorBarSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    a = a.seriesType;\n    var b = f.noop,\n        e = f.seriesTypes;\n    a(\"errorbar\", \"boxplot\", {\n      color: \"#000000\",\n      grouping: !1,\n      linkedTo: \":previous\",\n      tooltip: {\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>\"\n      },\n      whiskerWidth: null\n    }, {\n      type: \"errorbar\",\n      pointArrayMap: [\"low\", \"high\"],\n      toYData: function toYData(a) {\n        return [a.low, a.high];\n      },\n      pointValKey: \"high\",\n      doQuartiles: !1,\n      drawDataLabels: e.arearange ? function () {\n        var a = this.pointValKey;\n        e.arearange.prototype.drawDataLabels.call(this);\n        this.data.forEach(function (b) {\n          b.y = b[a];\n        });\n      } : b,\n      getColumnMetrics: function getColumnMetrics() {\n        return this.linkedParent && this.linkedParent.columnMetrics || e.column.prototype.getColumnMetrics.call(this);\n      }\n    });\n    \"\";\n  });\n  C(f, \"parts-more/WaterfallSeries.js\", [f[\"parts/Axis.js\"], f[\"parts/Chart.js\"], f[\"parts/Globals.js\"], f[\"parts/Point.js\"], f[\"parts/Stacking.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e, h, q) {\n    var t = q.addEvent,\n        x = q.arrayMax,\n        B = q.arrayMin,\n        z = q.correctFloat,\n        c = q.isNumber,\n        l = q.objectEach,\n        w = q.pick;\n    q = q.seriesType;\n    var p = b.Series,\n        y = b.seriesTypes,\n        v;\n\n    (function (a) {\n      function c() {\n        var d = this.waterfall.stacks;\n        d && (d.changed = !1, delete d.alreadyChanged);\n      }\n\n      function d() {\n        var d = this.options.stackLabels;\n        d && d.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function g() {\n        for (var d = this.axes, g = this.series, k = g.length; k--;) {\n          g[k].options.stacking && (d.forEach(function (d) {\n            d.isXAxis || (d.waterfall.stacks.changed = !0);\n          }), k = 0);\n        }\n      }\n\n      function k() {\n        this.waterfall || (this.waterfall = new u(this));\n      }\n\n      var u = function () {\n        function d(d) {\n          this.axis = d;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        d.prototype.renderStackTotals = function () {\n          var d = this.axis,\n              g = d.waterfall.stacks,\n              k = d.stacking && d.stacking.stackTotalGroup,\n              a = new h(d, d.options.stackLabels, !1, 0, void 0);\n          this.dummyStackItem = a;\n          l(g, function (d) {\n            l(d, function (d) {\n              a.total = d.stackTotal;\n              d.label && (a.label = d.label);\n              h.prototype.render.call(a, k);\n              d.label = a.label;\n              delete a.label;\n            });\n          });\n          a.total = null;\n        };\n\n        return d;\n      }();\n\n      a.Composition = u;\n\n      a.compose = function (a, r) {\n        t(a, \"init\", k);\n        t(a, \"afterBuildStacks\", c);\n        t(a, \"afterRender\", d);\n        t(r, \"beforeRedraw\", g);\n      };\n    })(v || (v = {}));\n\n    q(\"waterfall\", \"column\", {\n      dataLabels: {\n        inside: !0\n      },\n      lineWidth: 1,\n      lineColor: \"#333333\",\n      dashStyle: \"Dot\",\n      borderColor: \"#333333\",\n      states: {\n        hover: {\n          lineWidthPlus: 0\n        }\n      }\n    }, {\n      pointValKey: \"y\",\n      showLine: !0,\n      generatePoints: function generatePoints() {\n        var a;\n        y.column.prototype.generatePoints.apply(this);\n        var c = 0;\n\n        for (a = this.points.length; c < a; c++) {\n          var d = this.points[c];\n          var g = this.processedYData[c];\n          if (d.isIntermediateSum || d.isSum) d.y = z(g);\n        }\n      },\n      translate: function translate() {\n        var a = this.options,\n            c = this.yAxis,\n            d,\n            g = w(a.minPointLength, 5),\n            k = g / 2,\n            u = a.threshold,\n            A = a.stacking,\n            r = c.waterfall.stacks[this.stackKey];\n        y.column.prototype.translate.apply(this);\n        var b = d = u;\n        var e = this.points;\n        var l = 0;\n\n        for (a = e.length; l < a; l++) {\n          var h = e[l];\n          var f = this.processedYData[l];\n          var p = h.shapeArgs;\n          var q = [0, f];\n          var v = h.y;\n\n          if (A) {\n            if (r) {\n              q = r[l];\n\n              if (\"overlap\" === A) {\n                var t = q.stackState[q.stateIndex--];\n                t = 0 <= v ? t : t - v;\n                Object.hasOwnProperty.call(q, \"absolutePos\") && delete q.absolutePos;\n                Object.hasOwnProperty.call(q, \"absoluteNeg\") && delete q.absoluteNeg;\n              } else 0 <= v ? (t = q.threshold + q.posTotal, q.posTotal -= v) : (t = q.threshold + q.negTotal, q.negTotal -= v, t -= v), !q.posTotal && Object.hasOwnProperty.call(q, \"absolutePos\") && (q.posTotal = q.absolutePos, delete q.absolutePos), !q.negTotal && Object.hasOwnProperty.call(q, \"absoluteNeg\") && (q.negTotal = q.absoluteNeg, delete q.absoluteNeg);\n\n              h.isSum || (q.connectorThreshold = q.threshold + q.stackTotal);\n              c.reversed ? (f = 0 <= v ? t - v : t + v, v = t) : (f = t, v = t - v);\n              h.below = f <= w(u, 0);\n              p.y = c.translate(f, 0, 1, 0, 1);\n              p.height = Math.abs(p.y - c.translate(v, 0, 1, 0, 1));\n            }\n\n            if (v = c.waterfall.dummyStackItem) v.x = l, v.label = r[l].label, v.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[l], this.stackedYPos[l]);\n          } else t = Math.max(b, b + v) + q[0], p.y = c.translate(t, 0, 1, 0, 1), h.isSum ? (p.y = c.translate(q[1], 0, 1, 0, 1), p.height = Math.min(c.translate(q[0], 0, 1, 0, 1), c.len) - p.y) : h.isIntermediateSum ? (0 <= v ? (f = q[1] + d, v = d) : (f = d, v = q[1] + d), c.reversed && (f ^= v, v ^= f, f ^= v), p.y = c.translate(f, 0, 1, 0, 1), p.height = Math.abs(p.y - Math.min(c.translate(v, 0, 1, 0, 1), c.len)), d += q[1]) : (p.height = 0 < f ? c.translate(b, 0, 1, 0, 1) - p.y : c.translate(b, 0, 1, 0, 1) - c.translate(b - f, 0, 1, 0, 1), b += f, h.below = b < w(u, 0)), 0 > p.height && (p.y += p.height, p.height *= -1);\n\n          h.plotY = p.y = Math.round(p.y) - this.borderWidth % 2 / 2;\n          p.height = Math.max(Math.round(p.height), .001);\n          h.yBottom = p.y + p.height;\n          p.height <= g && !h.isNull ? (p.height = g, p.y -= k, h.plotY = p.y, h.minPointLengthOffset = 0 > h.y ? -k : k) : (h.isNull && (p.width = 0), h.minPointLengthOffset = 0);\n          p = h.plotY + (h.negative ? p.height : 0);\n          this.chart.inverted ? h.tooltipPos[0] = c.len - p : h.tooltipPos[1] = p;\n        }\n      },\n      processData: function processData(a) {\n        var c = this.options,\n            d = this.yData,\n            g = c.data,\n            k = d.length,\n            u = c.threshold || 0,\n            b,\n            r,\n            e,\n            l,\n            h;\n\n        for (h = r = b = e = l = 0; h < k; h++) {\n          var m = d[h];\n          var f = g && g[h] ? g[h] : {};\n          \"sum\" === m || f.isSum ? d[h] = z(r) : \"intermediateSum\" === m || f.isIntermediateSum ? (d[h] = z(b), b = 0) : (r += m, b += m);\n          e = Math.min(r, e);\n          l = Math.max(r, l);\n        }\n\n        p.prototype.processData.call(this, a);\n        c.stacking || (this.dataMin = e + u, this.dataMax = l);\n      },\n      toYData: function toYData(c) {\n        return c.isSum ? \"sum\" : c.isIntermediateSum ? \"intermediateSum\" : c.y;\n      },\n      updateParallelArrays: function updateParallelArrays(c, a) {\n        p.prototype.updateParallelArrays.call(this, c, a);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      },\n      pointAttribs: function pointAttribs(c, a) {\n        var d = this.options.upColor;\n        d && !c.options.color && (c.color = 0 < c.y ? d : null);\n        c = y.column.prototype.pointAttribs.call(this, c, a);\n        delete c.dashstyle;\n        return c;\n      },\n      getGraphPath: function getGraphPath() {\n        return [[\"M\", 0, 0]];\n      },\n      getCrispPath: function getCrispPath() {\n        var c = this.data,\n            a = this.yAxis,\n            d = c.length,\n            g = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            k = Math.round(this.borderWidth) % 2 / 2,\n            u = this.xAxis.reversed,\n            b = this.yAxis.reversed,\n            r = this.options.stacking,\n            e = [],\n            h;\n\n        for (h = 1; h < d; h++) {\n          var l = c[h].shapeArgs;\n          var f = c[h - 1];\n          var p = c[h - 1].shapeArgs;\n          var q = a.waterfall.stacks[this.stackKey];\n          var v = 0 < f.y ? -p.height : 0;\n          q && p && l && (q = q[h - 1], r ? (q = q.connectorThreshold, v = Math.round(a.translate(q, 0, 1, 0, 1) + (b ? v : 0)) - g) : v = p.y + f.minPointLengthOffset + k - g, e.push([\"M\", (p.x || 0) + (u ? 0 : p.width || 0), v], [\"L\", (l.x || 0) + (u ? l.width || 0 : 0), v]));\n          !r && e.length && p && (0 > f.y && !b || 0 < f.y && b) && (e[e.length - 2][2] += p.height, e[e.length - 1][2] += p.height);\n        }\n\n        return e;\n      },\n      drawGraph: function drawGraph() {\n        p.prototype.drawGraph.call(this);\n        this.graph.attr({\n          d: this.getCrispPath()\n        });\n      },\n      setStackedPoints: function setStackedPoints() {\n        function c(d, g, k, c) {\n          if (B) for (k; k < B; k++) {\n            w.stackState[k] += c;\n          } else w.stackState[0] = d, B = w.stackState.length;\n          w.stackState.push(w.stackState[B - 1] + g);\n        }\n\n        var a = this.options,\n            d = this.yAxis.waterfall.stacks,\n            g = a.threshold,\n            k = g || 0,\n            u = k,\n            b = this.stackKey,\n            r = this.xData,\n            e = r.length,\n            h,\n            l,\n            f;\n        this.yAxis.stacking.usePercentage = !1;\n        var p = l = f = k;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var q = d.changed;\n          (h = d.alreadyChanged) && 0 > h.indexOf(b) && (q = !0);\n          d[b] || (d[b] = {});\n          h = d[b];\n\n          for (var v = 0; v < e; v++) {\n            var t = r[v];\n            if (!h[t] || q) h[t] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: q && h[t] ? h[t].label : void 0\n            };\n            var w = h[t];\n            var y = this.yData[v];\n            0 <= y ? w.posTotal += y : w.negTotal += y;\n            var z = a.data[v];\n            t = w.absolutePos = w.posTotal;\n            var x = w.absoluteNeg = w.negTotal;\n            w.stackTotal = t + x;\n            var B = w.stackState.length;\n            z && z.isIntermediateSum ? (c(f, l, 0, f), f = l, l = g, k ^= u, u ^= k, k ^= u) : z && z.isSum ? (c(g, p, B), k = g) : (c(k, y, 0, p), z && (p += y, l += y));\n            w.stateIndex++;\n            w.threshold = k;\n            k += w.stackTotal;\n          }\n\n          d.changed = !1;\n          d.alreadyChanged || (d.alreadyChanged = []);\n          d.alreadyChanged.push(b);\n        }\n      },\n      getExtremes: function getExtremes() {\n        var c = this.options.stacking;\n\n        if (c) {\n          var a = this.yAxis;\n          a = a.waterfall.stacks;\n          var d = this.stackedYNeg = [];\n          var g = this.stackedYPos = [];\n          \"overlap\" === c ? l(a[this.stackKey], function (k) {\n            d.push(B(k.stackState));\n            g.push(x(k.stackState));\n          }) : l(a[this.stackKey], function (k) {\n            d.push(k.negTotal + k.threshold);\n            g.push(k.posTotal + k.threshold);\n          });\n          return {\n            dataMin: B(d),\n            dataMax: x(g)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      }\n    }, {\n      getClassName: function getClassName() {\n        var c = e.prototype.getClassName.call(this);\n        this.isSum ? c += \" highcharts-sum\" : this.isIntermediateSum && (c += \" highcharts-intermediate-sum\");\n        return c;\n      },\n      isValid: function isValid() {\n        return c(this.y) || this.isSum || !!this.isIntermediateSum;\n      }\n    });\n    \"\";\n    v.compose(f, a);\n    return v;\n  });\n  C(f, \"parts-more/PolygonSeries.js\", [f[\"parts/Globals.js\"], f[\"mixins/legend-symbol.js\"], f[\"parts/Utilities.js\"]], function (f, a, b) {\n    b = b.seriesType;\n    var e = f.Series,\n        h = f.seriesTypes;\n    b(\"polygon\", \"scatter\", {\n      marker: {\n        enabled: !1,\n        states: {\n          hover: {\n            enabled: !1\n          }\n        }\n      },\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"\"\n      },\n      trackByArea: !0\n    }, {\n      type: \"polygon\",\n      getGraphPath: function getGraphPath() {\n        for (var a = e.prototype.getGraphPath.call(this), b = a.length + 1; b--;) {\n          (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n        }\n\n        return this.areaPath = a;\n      },\n      drawGraph: function drawGraph() {\n        this.options.fillColor = this.color;\n        h.area.prototype.drawGraph.call(this);\n      },\n      drawLegendSymbol: a.drawRectangle,\n      drawTracker: e.prototype.drawTracker,\n      setStackedPoints: f.noop\n    });\n    \"\";\n  });\n  C(f, \"parts-more/BubbleLegend.js\", [f[\"parts/Chart.js\"], f[\"parts/Color.js\"], f[\"parts/Globals.js\"], f[\"parts/Legend.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e, h) {\n    var q = a.parse;\n    a = h.addEvent;\n    var t = h.arrayMax,\n        x = h.arrayMin,\n        B = h.isNumber,\n        z = h.merge,\n        c = h.objectEach,\n        l = h.pick,\n        w = h.setOptions,\n        p = h.stableSort,\n        y = h.wrap;\n    \"\";\n    var v = b.Series,\n        m = b.noop;\n    w({\n      legend: {\n        bubbleLegend: {\n          borderColor: void 0,\n          borderWidth: 2,\n          className: void 0,\n          color: void 0,\n          connectorClassName: void 0,\n          connectorColor: void 0,\n          connectorDistance: 60,\n          connectorWidth: 1,\n          enabled: !1,\n          labels: {\n            className: void 0,\n            allowOverlap: !1,\n            format: \"\",\n            formatter: void 0,\n            align: \"right\",\n            style: {\n              fontSize: 10,\n              color: void 0\n            },\n            x: 0,\n            y: 0\n          },\n          maxSize: 60,\n          minSize: 10,\n          legendIndex: 0,\n          ranges: {\n            value: void 0,\n            borderColor: void 0,\n            color: void 0,\n            connectorColor: void 0\n          },\n          sizeBy: \"area\",\n          sizeByAbsoluteValue: !1,\n          zIndex: 1,\n          zThreshold: 0\n        }\n      }\n    });\n\n    w = function () {\n      function a(d, g) {\n        this.options = this.symbols = this.visible = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = m;\n        this.init(d, g);\n      }\n\n      a.prototype.init = function (d, g) {\n        this.options = d;\n        this.visible = !0;\n        this.chart = g.chart;\n        this.legend = g;\n      };\n\n      a.prototype.addToLegend = function (d) {\n        d.splice(this.options.legendIndex, 0, this);\n      };\n\n      a.prototype.drawLegendSymbol = function (d) {\n        var g = this.chart,\n            k = this.options,\n            a = l(d.options.itemDistance, 20),\n            c = k.ranges;\n        var r = k.connectorDistance;\n        this.fontMetrics = g.renderer.fontMetrics(k.labels.style.fontSize.toString() + \"px\");\n        c && c.length && B(c[0].value) ? (p(c, function (d, g) {\n          return g.value - d.value;\n        }), this.ranges = c, this.setOptions(), this.render(), g = this.getMaxLabelSize(), c = this.ranges[0].radius, d = 2 * c, r = r - c + g.width, r = 0 < r ? r : 0, this.maxLabel = g, this.movementX = \"left\" === k.labels.align ? r : 0, this.legendItemWidth = d + r + a, this.legendItemHeight = d + this.fontMetrics.h / 2) : d.options.bubbleLegend.autoRanges = !0;\n      };\n\n      a.prototype.setOptions = function () {\n        var d = this.ranges,\n            g = this.options,\n            k = this.chart.series[g.seriesIndex],\n            c = this.legend.baseline,\n            a = {\n          \"z-index\": g.zIndex,\n          \"stroke-width\": g.borderWidth\n        },\n            r = {\n          \"z-index\": g.zIndex,\n          \"stroke-width\": g.connectorWidth\n        },\n            b = this.getLabelStyles(),\n            e = k.options.marker.fillOpacity,\n            h = this.chart.styledMode;\n        d.forEach(function (u, A) {\n          h || (a.stroke = l(u.borderColor, g.borderColor, k.color), a.fill = l(u.color, g.color, 1 !== e ? q(k.color).setOpacity(e).get(\"rgba\") : k.color), r.stroke = l(u.connectorColor, g.connectorColor, k.color));\n          d[A].radius = this.getRangeRadius(u.value);\n          d[A] = z(d[A], {\n            center: d[0].radius - d[A].radius + c\n          });\n          h || z(!0, d[A], {\n            bubbleStyle: z(!1, a),\n            connectorStyle: z(!1, r),\n            labelStyle: b\n          });\n        }, this);\n      };\n\n      a.prototype.getLabelStyles = function () {\n        var d = this.options,\n            g = {},\n            k = \"left\" === d.labels.align,\n            a = this.legend.options.rtl;\n        c(d.labels.style, function (d, k) {\n          \"color\" !== k && \"fontSize\" !== k && \"z-index\" !== k && (g[k] = d);\n        });\n        return z(!1, g, {\n          \"font-size\": d.labels.style.fontSize,\n          fill: l(d.labels.style.color, \"#000000\"),\n          \"z-index\": d.zIndex,\n          align: a || k ? \"right\" : \"left\"\n        });\n      };\n\n      a.prototype.getRangeRadius = function (d) {\n        var g = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, g.ranges[g.ranges.length - 1].value, g.ranges[0].value, g.minSize, g.maxSize, d);\n      };\n\n      a.prototype.render = function () {\n        var d = this.chart.renderer,\n            g = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = d.g(\"bubble-legend\");\n        this.legendItem = d.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (d) {\n          d.value >= g && this.renderRange(d);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      };\n\n      a.prototype.renderRange = function (d) {\n        var g = this.options,\n            k = g.labels,\n            a = this.chart.renderer,\n            c = this.symbols,\n            r = c.labels,\n            b = d.center,\n            e = Math.abs(d.radius),\n            h = g.connectorDistance || 0,\n            l = k.align,\n            n = k.style.fontSize;\n        h = this.legend.options.rtl || \"left\" === l ? -h : h;\n        k = g.connectorWidth;\n        var f = this.ranges[0].radius || 0,\n            p = b - e - g.borderWidth / 2 + k / 2;\n        n = n / 2 - (this.fontMetrics.h - n) / 2;\n        var m = a.styledMode;\n        \"center\" === l && (h = 0, g.connectorDistance = 0, d.labelStyle.align = \"center\");\n        l = p + g.labels.y;\n        var q = f + h + g.labels.x;\n        c.bubbleItems.push(a.circle(f, b + ((p % 1 ? 1 : .5) - (k % 2 ? 0 : .5)), e).attr(m ? {} : d.bubbleStyle).addClass((m ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (g.className || \"\")).add(this.legendSymbol));\n        c.connectors.push(a.path(a.crispLine([[\"M\", f, p], [\"L\", f + h, p]], g.connectorWidth)).attr(m ? {} : d.connectorStyle).addClass((m ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (g.connectorClassName || \"\")).add(this.legendSymbol));\n        d = a.text(this.formatLabel(d), q, l + n).attr(m ? {} : d.labelStyle).addClass(\"highcharts-bubble-legend-labels \" + (g.labels.className || \"\")).add(this.legendSymbol);\n        r.push(d);\n        d.placed = !0;\n        d.alignAttr = {\n          x: q,\n          y: l + n\n        };\n      };\n\n      a.prototype.getMaxLabelSize = function () {\n        var d, g;\n        this.symbols.labels.forEach(function (k) {\n          g = k.getBBox(!0);\n          d = d ? g.width > d.width ? g : d : g;\n        });\n        return d || {};\n      };\n\n      a.prototype.formatLabel = function (d) {\n        var g = this.options,\n            k = g.labels.formatter;\n        g = g.labels.format;\n        var a = this.chart.numberFormatter;\n        return g ? h.format(g, d) : k ? k.call(d) : a(d.value, 1);\n      };\n\n      a.prototype.hideOverlappingLabels = function () {\n        var d = this.chart,\n            g = this.symbols;\n        !this.options.labels.allowOverlap && g && (d.hideOverlappingLabels(g.labels), g.labels.forEach(function (d, a) {\n          d.newOpacity ? d.newOpacity !== d.oldOpacity && g.connectors[a].show() : g.connectors[a].hide();\n        }));\n      };\n\n      a.prototype.getRanges = function () {\n        var d = this.legend.bubbleLegend,\n            g = d.options.ranges,\n            k,\n            a = Number.MAX_VALUE,\n            c = -Number.MAX_VALUE;\n        d.chart.series.forEach(function (d) {\n          d.isBubble && !d.ignoreSeries && (k = d.zData.filter(B), k.length && (a = l(d.options.zMin, Math.min(a, Math.max(x(k), !1 === d.options.displayNegative ? d.options.zThreshold : -Number.MAX_VALUE))), c = l(d.options.zMax, Math.max(c, t(k)))));\n        });\n        var b = a === c ? [{\n          value: c\n        }] : [{\n          value: a\n        }, {\n          value: (a + c) / 2\n        }, {\n          value: c,\n          autoRanges: !0\n        }];\n        g.length && g[0].radius && b.reverse();\n        b.forEach(function (d, k) {\n          g && g[k] && (b[k] = z(!1, g[k], d));\n        });\n        return b;\n      };\n\n      a.prototype.predictBubbleSizes = function () {\n        var d = this.chart,\n            g = this.fontMetrics,\n            k = d.legend.options,\n            a = \"horizontal\" === k.layout,\n            c = a ? d.legend.lastLineHeight : 0,\n            b = d.plotSizeX,\n            e = d.plotSizeY,\n            h = d.series[this.options.seriesIndex];\n        d = Math.ceil(h.minPxSize);\n        var l = Math.ceil(h.maxPxSize);\n        h = h.options.maxSize;\n        var n = Math.min(e, b);\n        if (k.floating || !/%$/.test(h)) g = l;else if (h = parseFloat(h), g = (n + c - g.h / 2) * h / 100 / (h / 100 + 1), a && e - g >= b || !a && b - g >= e) g = l;\n        return [d, Math.ceil(g)];\n      };\n\n      a.prototype.updateRanges = function (d, g) {\n        var k = this.legend.options.bubbleLegend;\n        k.minSize = d;\n        k.maxSize = g;\n        k.ranges = this.getRanges();\n      };\n\n      a.prototype.correctSizes = function () {\n        var d = this.legend,\n            g = this.chart.series[this.options.seriesIndex];\n        1 < Math.abs(Math.ceil(g.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, g.maxPxSize), d.render());\n      };\n\n      return a;\n    }();\n\n    a(e, \"afterGetAllItems\", function (a) {\n      var d = this.bubbleLegend,\n          g = this.options,\n          k = g.bubbleLegend,\n          c = this.chart.getVisibleBubbleSeriesIndex();\n      d && d.ranges && d.ranges.length && (k.ranges.length && (k.autoRanges = !!k.ranges[0].autoRanges), this.destroyItem(d));\n      0 <= c && g.enabled && k.enabled && (k.seriesIndex = c, this.bubbleLegend = new b.BubbleLegend(k, this), this.bubbleLegend.addToLegend(a.allItems));\n    });\n\n    f.prototype.getVisibleBubbleSeriesIndex = function () {\n      for (var a = this.series, d = 0; d < a.length;) {\n        if (a[d] && a[d].isBubble && a[d].visible && a[d].zData.length) return d;\n        d++;\n      }\n\n      return -1;\n    };\n\n    e.prototype.getLinesHeights = function () {\n      var a = this.allItems,\n          d = [],\n          g = a.length,\n          k,\n          c = 0;\n\n      for (k = 0; k < g; k++) {\n        if (a[k].legendItemHeight && (a[k].itemHeight = a[k].legendItemHeight), a[k] === a[g - 1] || a[k + 1] && a[k]._legendItemPos[1] !== a[k + 1]._legendItemPos[1]) {\n          d.push({\n            height: 0\n          });\n          var b = d[d.length - 1];\n\n          for (c; c <= k; c++) {\n            a[c].itemHeight > b.height && (b.height = a[c].itemHeight);\n          }\n\n          b.step = k;\n        }\n      }\n\n      return d;\n    };\n\n    e.prototype.retranslateItems = function (a) {\n      var d,\n          g,\n          k,\n          c = this.options.rtl,\n          b = 0;\n      this.allItems.forEach(function (r, e) {\n        d = r.legendGroup.translateX;\n        g = r._legendItemPos[1];\n        if ((k = r.movementX) || c && r.ranges) k = c ? d - r.options.maxSize / 2 : d + k, r.legendGroup.attr({\n          translateX: k\n        });\n        e > a[b].step && b++;\n        r.legendGroup.attr({\n          translateY: Math.round(g + a[b].height / 2)\n        });\n        r._legendItemPos[1] = g + a[b].height / 2;\n      });\n    };\n\n    a(v, \"legendItemClick\", function () {\n      var a = this.chart,\n          d = this.visible,\n          g = this.chart.legend;\n      g && g.bubbleLegend && (this.visible = !d, this.ignoreSeries = d, a = 0 <= a.getVisibleBubbleSeriesIndex(), g.bubbleLegend.visible !== a && (g.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), g.bubbleLegend.visible = a), this.visible = d);\n    });\n    y(f.prototype, \"drawChartBox\", function (a, d, g) {\n      var k = this.legend,\n          b = 0 <= this.getVisibleBubbleSeriesIndex();\n\n      if (k && k.options.enabled && k.bubbleLegend && k.options.bubbleLegend.autoRanges && b) {\n        var e = k.bubbleLegend.options;\n        b = k.bubbleLegend.predictBubbleSizes();\n        k.bubbleLegend.updateRanges(b[0], b[1]);\n        e.placed || (k.group.placed = !1, k.allItems.forEach(function (d) {\n          d.legendGroup.translateY = null;\n        }));\n        k.render();\n        this.getMargins();\n        this.axes.forEach(function (d) {\n          d.visible && d.render();\n          e.placed || (d.setScale(), d.updateNames(), c(d.ticks, function (d) {\n            d.isNew = !0;\n            d.isNewLabel = !0;\n          }));\n        });\n        e.placed = !0;\n        this.getMargins();\n        a.call(this, d, g);\n        k.bubbleLegend.correctSizes();\n        k.retranslateItems(k.getLinesHeights());\n      } else a.call(this, d, g), k && k.options.enabled && k.bubbleLegend && (k.render(), k.retranslateItems(k.getLinesHeights()));\n    });\n    b.BubbleLegend = w;\n    return b.BubbleLegend;\n  });\n  C(f, \"parts-more/BubbleSeries.js\", [f[\"parts/Globals.js\"], f[\"parts/Color.js\"], f[\"parts/Point.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e) {\n    var h = a.parse,\n        q = e.arrayMax,\n        t = e.arrayMin,\n        x = e.clamp,\n        B = e.extend,\n        z = e.isNumber,\n        c = e.pick,\n        l = e.pInt;\n    a = e.seriesType;\n    e = f.Axis;\n    var w = f.noop,\n        p = f.Series,\n        y = f.seriesTypes;\n    a(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      isBubble: !0,\n      pointAttribs: function pointAttribs(a, c) {\n        var b = this.options.marker.fillOpacity;\n        a = p.prototype.pointAttribs.call(this, a, c);\n        1 !== b && (a.fill = h(a.fill).setOpacity(b).get(\"rgba\"));\n        return a;\n      },\n      getRadii: function getRadii(a, c, b) {\n        var d = this.zData,\n            g = this.yData,\n            k = b.minPxSize,\n            e = b.maxPxSize,\n            h = [];\n        var r = 0;\n\n        for (b = d.length; r < b; r++) {\n          var l = d[r];\n          h.push(this.getRadius(a, c, k, e, l, g[r]));\n        }\n\n        this.radii = h;\n      },\n      getRadius: function getRadius(a, c, b, d, g, k) {\n        var e = this.options,\n            h = \"width\" !== e.sizeBy,\n            r = e.zThreshold,\n            l = c - a,\n            f = .5;\n        if (null === k || null === g) return null;\n\n        if (z(g)) {\n          e.sizeByAbsoluteValue && (g = Math.abs(g - r), l = Math.max(c - r, Math.abs(a - r)), a = 0);\n          if (g < a) return b / 2 - 1;\n          0 < l && (f = (g - a) / l);\n        }\n\n        h && 0 <= f && (f = Math.sqrt(f));\n        return Math.ceil(b + f * (d - b)) / 2;\n      },\n      animate: function animate(a) {\n        !a && this.points.length < this.options.animationLimit && this.points.forEach(function (a) {\n          var c = a.graphic;\n          c && c.width && (this.hasRendered || c.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), c.animate(this.markerAttribs(a), this.options.animation));\n        }, this);\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      translate: function translate() {\n        var a,\n            c = this.data,\n            b = this.radii;\n        y.scatter.prototype.translate.call(this);\n\n        for (a = c.length; a--;) {\n          var d = c[a];\n          var g = b ? b[a] : 0;\n          z(g) && g >= this.minPxSize / 2 ? (d.marker = B(d.marker, {\n            radius: g,\n            width: 2 * g,\n            height: 2 * g\n          }), d.dlBox = {\n            x: d.plotX - g,\n            y: d.plotY - g,\n            width: 2 * g,\n            height: 2 * g\n          }) : d.shapeArgs = d.plotY = d.dlBox = void 0;\n        }\n      },\n      alignDataLabel: y.column.prototype.alignDataLabel,\n      buildKDTree: w,\n      applyZones: w\n    }, {\n      haloPath: function haloPath(a) {\n        return b.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      },\n      ttBelow: !1\n    });\n\n    e.prototype.beforePadding = function () {\n      var a = this,\n          b = this.len,\n          e = this.chart,\n          d = 0,\n          g = b,\n          k = this.isXAxis,\n          h = k ? \"xData\" : \"yData\",\n          f = this.min,\n          r = {},\n          p = Math.min(e.plotWidth, e.plotHeight),\n          w = Number.MAX_VALUE,\n          y = -Number.MAX_VALUE,\n          B = this.max - f,\n          E = b / B,\n          F = [];\n      this.series.forEach(function (d) {\n        var g = d.options;\n        !d.bubblePadding || !d.visible && e.options.chart.ignoreHiddenSeries || (a.allowZoomOutside = !0, F.push(d), k && ([\"minSize\", \"maxSize\"].forEach(function (d) {\n          var a = g[d],\n              c = /%$/.test(a);\n          a = l(a);\n          r[d] = c ? p * a / 100 : a;\n        }), d.minPxSize = r.minSize, d.maxPxSize = Math.max(r.maxSize, r.minSize), d = d.zData.filter(z), d.length && (w = c(g.zMin, x(t(d), !1 === g.displayNegative ? g.zThreshold : -Number.MAX_VALUE, w)), y = c(g.zMax, Math.max(y, q(d))))));\n      });\n      F.forEach(function (c) {\n        var b = c[h],\n            e = b.length;\n        k && c.getRadii(w, y, c);\n        if (0 < B) for (; e--;) {\n          if (z(b[e]) && a.dataMin <= b[e] && b[e] <= a.max) {\n            var r = c.radii ? c.radii[e] : 0;\n            d = Math.min((b[e] - f) * E - r, d);\n            g = Math.max((b[e] - f) * E + r, g);\n          }\n        }\n      });\n      F.length && 0 < B && !this.logarithmic && (g -= b, E *= (b + Math.max(0, d) - Math.min(g, b)) / b, [[\"min\", \"userMin\", d], [\"max\", \"userMax\", g]].forEach(function (d) {\n        \"undefined\" === typeof c(a.options[d[0]], a[d[1]]) && (a[d[0]] += d[2] / E);\n      }));\n    };\n\n    \"\";\n  });\n  C(f, \"modules/networkgraph/integrations.js\", [f[\"parts/Globals.js\"]], function (f) {\n    f.networkgraphIntegrations = {\n      verlet: {\n        attractiveForceFunction: function attractiveForceFunction(a, b) {\n          return (b - a) / a;\n        },\n        repulsiveForceFunction: function repulsiveForceFunction(a, b) {\n          return (b - a) / a * (b > a ? 1 : 0);\n        },\n        barycenter: function barycenter() {\n          var a = this.options.gravitationalConstant,\n              b = this.barycenter.xFactor,\n              e = this.barycenter.yFactor;\n          b = (b - (this.box.left + this.box.width) / 2) * a;\n          e = (e - (this.box.top + this.box.height) / 2) * a;\n          this.nodes.forEach(function (a) {\n            a.fixedPosition || (a.plotX -= b / a.mass / a.degree, a.plotY -= e / a.mass / a.degree);\n          });\n        },\n        repulsive: function repulsive(a, b, e) {\n          b = b * this.diffTemperature / a.mass / a.degree;\n          a.fixedPosition || (a.plotX += e.x * b, a.plotY += e.y * b);\n        },\n        attractive: function attractive(a, b, e) {\n          var h = a.getMass(),\n              f = -e.x * b * this.diffTemperature;\n          b = -e.y * b * this.diffTemperature;\n          a.fromNode.fixedPosition || (a.fromNode.plotX -= f * h.fromNode / a.fromNode.degree, a.fromNode.plotY -= b * h.fromNode / a.fromNode.degree);\n          a.toNode.fixedPosition || (a.toNode.plotX += f * h.toNode / a.toNode.degree, a.toNode.plotY += b * h.toNode / a.toNode.degree);\n        },\n        integrate: function integrate(a, b) {\n          var e = -a.options.friction,\n              h = a.options.maxSpeed,\n              f = (b.plotX + b.dispX - b.prevX) * e;\n          e *= b.plotY + b.dispY - b.prevY;\n          var t = Math.abs,\n              x = t(f) / (f || 1);\n          t = t(e) / (e || 1);\n          f = x * Math.min(h, Math.abs(f));\n          e = t * Math.min(h, Math.abs(e));\n          b.prevX = b.plotX + b.dispX;\n          b.prevY = b.plotY + b.dispY;\n          b.plotX += f;\n          b.plotY += e;\n          b.temperature = a.vectorLength({\n            x: f,\n            y: e\n          });\n        },\n        getK: function getK(a) {\n          return Math.pow(a.box.width * a.box.height / a.nodes.length, .5);\n        }\n      },\n      euler: {\n        attractiveForceFunction: function attractiveForceFunction(a, b) {\n          return a * a / b;\n        },\n        repulsiveForceFunction: function repulsiveForceFunction(a, b) {\n          return b * b / a;\n        },\n        barycenter: function barycenter() {\n          var a = this.options.gravitationalConstant,\n              b = this.barycenter.xFactor,\n              e = this.barycenter.yFactor;\n          this.nodes.forEach(function (h) {\n            if (!h.fixedPosition) {\n              var f = h.getDegree();\n              f *= 1 + f / 2;\n              h.dispX += (b - h.plotX) * a * f / h.degree;\n              h.dispY += (e - h.plotY) * a * f / h.degree;\n            }\n          });\n        },\n        repulsive: function repulsive(a, b, e, h) {\n          a.dispX += e.x / h * b / a.degree;\n          a.dispY += e.y / h * b / a.degree;\n        },\n        attractive: function attractive(a, b, e, h) {\n          var f = a.getMass(),\n              t = e.x / h * b;\n          b *= e.y / h;\n          a.fromNode.fixedPosition || (a.fromNode.dispX -= t * f.fromNode / a.fromNode.degree, a.fromNode.dispY -= b * f.fromNode / a.fromNode.degree);\n          a.toNode.fixedPosition || (a.toNode.dispX += t * f.toNode / a.toNode.degree, a.toNode.dispY += b * f.toNode / a.toNode.degree);\n        },\n        integrate: function integrate(a, b) {\n          b.dispX += b.dispX * a.options.friction;\n          b.dispY += b.dispY * a.options.friction;\n          var e = b.temperature = a.vectorLength({\n            x: b.dispX,\n            y: b.dispY\n          });\n          0 !== e && (b.plotX += b.dispX / e * Math.min(Math.abs(b.dispX), a.temperature), b.plotY += b.dispY / e * Math.min(Math.abs(b.dispY), a.temperature));\n        },\n        getK: function getK(a) {\n          return Math.pow(a.box.width * a.box.height / a.nodes.length, .3);\n        }\n      }\n    };\n  });\n  C(f, \"modules/networkgraph/QuadTree.js\", [f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a) {\n    a = a.extend;\n\n    var b = f.QuadTreeNode = function (a) {\n      this.box = a;\n      this.boxSize = Math.min(a.width, a.height);\n      this.nodes = [];\n      this.body = this.isInternal = !1;\n      this.isEmpty = !0;\n    };\n\n    a(b.prototype, {\n      insert: function insert(a, h) {\n        this.isInternal ? this.nodes[this.getBoxPosition(a)].insert(a, h - 1) : (this.isEmpty = !1, this.body ? h ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, h - 1), this.body = !0), this.nodes[this.getBoxPosition(a)].insert(a, h - 1)) : (h = new b({\n          top: a.plotX,\n          left: a.plotY,\n          width: .1,\n          height: .1\n        }), h.body = a, h.isInternal = !1, this.nodes.push(h)) : (this.isInternal = !1, this.body = a));\n      },\n      updateMassAndCenter: function updateMassAndCenter() {\n        var a = 0,\n            b = 0,\n            f = 0;\n        this.isInternal ? (this.nodes.forEach(function (e) {\n          e.isEmpty || (a += e.mass, b += e.plotX * e.mass, f += e.plotY * e.mass);\n        }), b /= a, f /= a) : this.body && (a = this.body.mass, b = this.body.plotX, f = this.body.plotY);\n        this.mass = a;\n        this.plotX = b;\n        this.plotY = f;\n      },\n      divideBox: function divideBox() {\n        var a = this.box.width / 2,\n            h = this.box.height / 2;\n        this.nodes[0] = new b({\n          left: this.box.left,\n          top: this.box.top,\n          width: a,\n          height: h\n        });\n        this.nodes[1] = new b({\n          left: this.box.left + a,\n          top: this.box.top,\n          width: a,\n          height: h\n        });\n        this.nodes[2] = new b({\n          left: this.box.left + a,\n          top: this.box.top + h,\n          width: a,\n          height: h\n        });\n        this.nodes[3] = new b({\n          left: this.box.left,\n          top: this.box.top + h,\n          width: a,\n          height: h\n        });\n      },\n      getBoxPosition: function getBoxPosition(a) {\n        var b = a.plotY < this.box.top + this.box.height / 2;\n        return a.plotX < this.box.left + this.box.width / 2 ? b ? 0 : 3 : b ? 1 : 2;\n      }\n    });\n\n    f = f.QuadTree = function (a, h, f, t) {\n      this.box = {\n        left: a,\n        top: h,\n        width: f,\n        height: t\n      };\n      this.maxDepth = 25;\n      this.root = new b(this.box, \"0\");\n      this.root.isInternal = !0;\n      this.root.isRoot = !0;\n      this.root.divideBox();\n    };\n\n    a(f.prototype, {\n      insertNodes: function insertNodes(a) {\n        a.forEach(function (a) {\n          this.root.insert(a, this.maxDepth);\n        }, this);\n      },\n      visitNodeRecursive: function visitNodeRecursive(a, b, f) {\n        var e;\n        a || (a = this.root);\n        a === this.root && b && (e = b(a));\n        !1 !== e && (a.nodes.forEach(function (a) {\n          if (a.isInternal) {\n            b && (e = b(a));\n            if (!1 === e) return;\n            this.visitNodeRecursive(a, b, f);\n          } else a.body && b && b(a.body);\n\n          f && f(a);\n        }, this), a === this.root && f && f(a));\n      },\n      calculateMassAndCenter: function calculateMassAndCenter() {\n        this.visitNodeRecursive(null, null, function (a) {\n          a.updateMassAndCenter();\n        });\n      }\n    });\n  });\n  C(f, \"modules/networkgraph/layouts.js\", [f[\"parts/Chart.js\"], f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a, b) {\n    var e = b.addEvent,\n        h = b.clamp,\n        q = b.defined,\n        t = b.extend,\n        x = b.isFunction,\n        B = b.pick,\n        z = b.setAnimation;\n    a.layouts = {\n      \"reingold-fruchterman\": function reingoldFruchterman() {}\n    };\n    t(a.layouts[\"reingold-fruchterman\"].prototype, {\n      init: function init(c) {\n        this.options = c;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = a.networkgraphIntegrations[c.integration];\n        this.enableSimulation = c.enableSimulation;\n        this.attractiveForce = B(c.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = B(c.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = c.approximation;\n      },\n      updateSimulation: function updateSimulation(a) {\n        this.enableSimulation = B(a, this.options.enableSimulation);\n      },\n      start: function start() {\n        var a = this.series,\n            b = this.options;\n        this.currentStep = 0;\n        this.forces = a[0] && a[0].forces || [];\n        this.chart = a[0] && a[0].chart;\n        this.initialRendering && (this.initPositions(), a.forEach(function (a) {\n          a.finishedAnimating = !0;\n          a.render();\n        }));\n        this.setK();\n        this.resetSimulation(b);\n        this.enableSimulation && this.step();\n      },\n      step: function step() {\n        var c = this,\n            b = this.series;\n        c.currentStep++;\n        \"barnes-hut\" === c.approximation && (c.createQuadTree(), c.quadTree.calculateMassAndCenter());\n        c.forces.forEach(function (a) {\n          c[a + \"Forces\"](c.temperature);\n        });\n        c.applyLimits(c.temperature);\n        c.temperature = c.coolDown(c.startTemperature, c.diffTemperature, c.currentStep);\n        c.prevSystemTemperature = c.systemTemperature;\n        c.systemTemperature = c.getSystemTemperature();\n        c.enableSimulation && (b.forEach(function (a) {\n          a.chart && a.render();\n        }), c.maxIterations-- && isFinite(c.temperature) && !c.isStable() ? (c.simulation && a.win.cancelAnimationFrame(c.simulation), c.simulation = a.win.requestAnimationFrame(function () {\n          c.step();\n        })) : c.simulation = !1);\n      },\n      stop: function stop() {\n        this.simulation && a.win.cancelAnimationFrame(this.simulation);\n      },\n      setArea: function setArea(a, b, e, f) {\n        this.box = {\n          left: a,\n          top: b,\n          width: e,\n          height: f\n        };\n      },\n      setK: function setK() {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      },\n      addElementsToCollection: function addElementsToCollection(a, b) {\n        a.forEach(function (a) {\n          -1 === b.indexOf(a) && b.push(a);\n        });\n      },\n      removeElementFromCollection: function removeElementFromCollection(a, b) {\n        a = b.indexOf(a);\n        -1 !== a && b.splice(a, 1);\n      },\n      clear: function clear() {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      },\n      resetSimulation: function resetSimulation() {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      },\n      restartSimulation: function restartSimulation() {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      },\n      setMaxIterations: function setMaxIterations(a) {\n        this.maxIterations = B(a, this.options.maxIterations);\n      },\n      setTemperature: function setTemperature() {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      },\n      setDiffTemperature: function setDiffTemperature() {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      },\n      setInitialRendering: function setInitialRendering(a) {\n        this.initialRendering = a;\n      },\n      createQuadTree: function createQuadTree() {\n        this.quadTree = new a.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      },\n      initPositions: function initPositions() {\n        var a = this.options.initialPositions;\n        x(a) ? (a.call(this), this.nodes.forEach(function (a) {\n          q(a.prevX) || (a.prevX = a.plotX);\n          q(a.prevY) || (a.prevY = a.plotY);\n          a.dispX = 0;\n          a.dispY = 0;\n        })) : \"circle\" === a ? this.setCircularPositions() : this.setRandomPositions();\n      },\n      setCircularPositions: function setCircularPositions() {\n        function a(d) {\n          d.linksFrom.forEach(function (d) {\n            m[d.toNode.id] || (m[d.toNode.id] = !0, q.push(d.toNode), a(d.toNode));\n          });\n        }\n\n        var b = this.box,\n            e = this.nodes,\n            f = 2 * Math.PI / (e.length + 1),\n            h = e.filter(function (a) {\n          return 0 === a.linksTo.length;\n        }),\n            q = [],\n            m = {},\n            n = this.options.initialPositionRadius;\n        h.forEach(function (d) {\n          q.push(d);\n          a(d);\n        });\n        q.length ? e.forEach(function (a) {\n          -1 === q.indexOf(a) && q.push(a);\n        }) : q = e;\n        q.forEach(function (a, g) {\n          a.plotX = a.prevX = B(a.plotX, b.width / 2 + n * Math.cos(g * f));\n          a.plotY = a.prevY = B(a.plotY, b.height / 2 + n * Math.sin(g * f));\n          a.dispX = 0;\n          a.dispY = 0;\n        });\n      },\n      setRandomPositions: function setRandomPositions() {\n        function a(a) {\n          a = a * a / Math.PI;\n          return a -= Math.floor(a);\n        }\n\n        var b = this.box,\n            e = this.nodes,\n            f = e.length + 1;\n        e.forEach(function (c, e) {\n          c.plotX = c.prevX = B(c.plotX, b.width * a(e));\n          c.plotY = c.prevY = B(c.plotY, b.height * a(f + e));\n          c.dispX = 0;\n          c.dispY = 0;\n        });\n      },\n      force: function force(a) {\n        this.integration[a].apply(this, Array.prototype.slice.call(arguments, 1));\n      },\n      barycenterForces: function barycenterForces() {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      },\n      getBarycenter: function getBarycenter() {\n        var a = 0,\n            b = 0,\n            e = 0;\n        this.nodes.forEach(function (c) {\n          b += c.plotX * c.mass;\n          e += c.plotY * c.mass;\n          a += c.mass;\n        });\n        return this.barycenter = {\n          x: b,\n          y: e,\n          xFactor: b / a,\n          yFactor: e / a\n        };\n      },\n      barnesHutApproximation: function barnesHutApproximation(a, b) {\n        var c = this.getDistXY(a, b),\n            e = this.vectorLength(c);\n        if (a !== b && 0 !== e) if (b.isInternal) {\n          if (b.boxSize / e < this.options.theta && 0 !== e) {\n            var f = this.repulsiveForce(e, this.k);\n            this.force(\"repulsive\", a, f * b.mass, c, e);\n            var h = !1;\n          } else h = !0;\n        } else f = this.repulsiveForce(e, this.k), this.force(\"repulsive\", a, f * b.mass, c, e);\n        return h;\n      },\n      repulsiveForces: function repulsiveForces() {\n        var a = this;\n        \"barnes-hut\" === a.approximation ? a.nodes.forEach(function (c) {\n          a.quadTree.visitNodeRecursive(null, function (b) {\n            return a.barnesHutApproximation(c, b);\n          });\n        }) : a.nodes.forEach(function (c) {\n          a.nodes.forEach(function (b) {\n            if (c !== b && !c.fixedPosition) {\n              var e = a.getDistXY(c, b);\n              var f = a.vectorLength(e);\n\n              if (0 !== f) {\n                var h = a.repulsiveForce(f, a.k);\n                a.force(\"repulsive\", c, h * b.mass, e, f);\n              }\n            }\n          });\n        });\n      },\n      attractiveForces: function attractiveForces() {\n        var a = this,\n            b,\n            e,\n            f;\n        a.links.forEach(function (c) {\n          c.fromNode && c.toNode && (b = a.getDistXY(c.fromNode, c.toNode), e = a.vectorLength(b), 0 !== e && (f = a.attractiveForce(e, a.k), a.force(\"attractive\", c, f, b, e)));\n        });\n      },\n      applyLimits: function applyLimits() {\n        var a = this;\n        a.nodes.forEach(function (c) {\n          c.fixedPosition || (a.integration.integrate(a, c), a.applyLimitBox(c, a.box), c.dispX = 0, c.dispY = 0);\n        });\n      },\n      applyLimitBox: function applyLimitBox(a, b) {\n        var c = a.radius;\n        a.plotX = h(a.plotX, b.left + c, b.width - c);\n        a.plotY = h(a.plotY, b.top + c, b.height - c);\n      },\n      coolDown: function coolDown(a, b, e) {\n        return a - b * e;\n      },\n      isStable: function isStable() {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      },\n      getSystemTemperature: function getSystemTemperature() {\n        return this.nodes.reduce(function (a, b) {\n          return a + b.temperature;\n        }, 0);\n      },\n      vectorLength: function vectorLength(a) {\n        return Math.sqrt(a.x * a.x + a.y * a.y);\n      },\n      getDistR: function getDistR(a, b) {\n        a = this.getDistXY(a, b);\n        return this.vectorLength(a);\n      },\n      getDistXY: function getDistXY(a, b) {\n        var c = a.plotX - b.plotX;\n        a = a.plotY - b.plotY;\n        return {\n          x: c,\n          y: a,\n          absX: Math.abs(c),\n          absY: Math.abs(a)\n        };\n      }\n    });\n    e(f, \"predraw\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.stop();\n      });\n    });\n    e(f, \"render\", function () {\n      function a(a) {\n        a.maxIterations-- && isFinite(a.temperature) && !a.isStable() && !a.enableSimulation && (a.beforeStep && a.beforeStep(), a.step(), e = !1, b = !0);\n      }\n\n      var b = !1;\n\n      if (this.graphLayoutsLookup) {\n        z(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (a) {\n          a.start();\n        }); !e;) {\n          var e = !0;\n          this.graphLayoutsLookup.forEach(a);\n        }\n\n        b && this.series.forEach(function (a) {\n          a && a.layout && a.render();\n        });\n      }\n    });\n    e(f, \"beforePrint\", function () {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation(!1);\n      }), this.redraw());\n    });\n    e(f, \"afterPrint\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (a) {\n        a.updateSimulation();\n      });\n      this.redraw();\n    });\n  });\n  C(f, \"modules/networkgraph/draggable-nodes.js\", [f[\"parts/Chart.js\"], f[\"parts/Globals.js\"], f[\"parts/Utilities.js\"]], function (f, a, b) {\n    var e = b.addEvent;\n    a.dragNodesMixin = {\n      onMouseDown: function onMouseDown(a, b) {\n        b = this.chart.pointer.normalize(b);\n        a.fixedPosition = {\n          chartX: b.chartX,\n          chartY: b.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function onMouseMove(a, b) {\n        if (a.fixedPosition && a.inDragMode) {\n          var e = this.chart;\n          b = e.pointer.normalize(b);\n          var f = a.fixedPosition.chartX - b.chartX,\n              h = a.fixedPosition.chartY - b.chartY;\n          b = e.graphLayoutsLookup;\n          if (5 < Math.abs(f) || 5 < Math.abs(h)) f = a.fixedPosition.plotX - f, h = a.fixedPosition.plotY - h, e.isInsidePlot(f, h) && (a.plotX = f, a.plotY = h, a.hasDragged = !0, this.redrawHalo(a), b.forEach(function (a) {\n            a.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function onMouseUp(a, b) {\n        a.fixedPosition && a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw(), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function redrawHalo(a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n    e(f, \"load\", function () {\n      var a = this,\n          b,\n          f,\n          x;\n      a.container && (b = e(a.container, \"mousedown\", function (b) {\n        var h = a.hoverPoint;\n        h && h.series && h.series.hasDraggableNodes && h.series.options.draggable && (h.series.onMouseDown(h, b), f = e(a.container, \"mousemove\", function (a) {\n          return h && h.series && h.series.onMouseMove(h, a);\n        }), x = e(a.container.ownerDocument, \"mouseup\", function (a) {\n          f();\n          x();\n          return h && h.series && h.series.onMouseUp(h, a);\n        }));\n      }));\n      e(a, \"destroy\", function () {\n        b();\n      });\n    });\n  });\n  C(f, \"parts-more/PackedBubbleSeries.js\", [f[\"parts/Chart.js\"], f[\"parts/Color.js\"], f[\"parts/Globals.js\"], f[\"parts/Point.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e, h) {\n    var q = a.parse,\n        t = h.addEvent,\n        x = h.clamp,\n        B = h.defined,\n        z = h.extend;\n    a = h.extendClass;\n    var c = h.fireEvent,\n        l = h.isArray,\n        w = h.isNumber,\n        p = h.merge,\n        y = h.pick;\n    h = h.seriesType;\n    var v = b.Series,\n        m = b.layouts[\"reingold-fruchterman\"],\n        n = b.dragNodesMixin;\n\n    f.prototype.getSelectedParentNodes = function () {\n      var a = [];\n      this.series.forEach(function (d) {\n        d.parentNode && d.parentNode.selected && a.push(d.parentNode);\n      });\n      return a;\n    };\n\n    b.networkgraphIntegrations.packedbubble = {\n      repulsiveForceFunction: function repulsiveForceFunction(a, g, b, c) {\n        return Math.min(a, (b.marker.radius + c.marker.radius) / 2);\n      },\n      barycenter: function barycenter() {\n        var a = this,\n            g = a.options.gravitationalConstant,\n            b = a.box,\n            c = a.nodes,\n            e,\n            f;\n        c.forEach(function (d) {\n          a.options.splitSeries && !d.isParentNode ? (e = d.series.parentNode.plotX, f = d.series.parentNode.plotY) : (e = b.width / 2, f = b.height / 2);\n          d.fixedPosition || (d.plotX -= (d.plotX - e) * g / (d.mass * Math.sqrt(c.length)), d.plotY -= (d.plotY - f) * g / (d.mass * Math.sqrt(c.length)));\n        });\n      },\n      repulsive: function repulsive(a, g, b, c) {\n        var d = g * this.diffTemperature / a.mass / a.degree;\n        g = b.x * d;\n        b = b.y * d;\n        a.fixedPosition || (a.plotX += g, a.plotY += b);\n        c.fixedPosition || (c.plotX -= g, c.plotY -= b);\n      },\n      integrate: b.networkgraphIntegrations.verlet.integrate,\n      getK: b.noop\n    };\n    b.layouts.packedbubble = a(m, {\n      beforeStep: function beforeStep() {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      },\n      setCircularPositions: function setCircularPositions() {\n        var a = this,\n            g = a.box,\n            b = a.nodes,\n            c = 2 * Math.PI / (b.length + 1),\n            e,\n            f,\n            h = a.options.initialPositionRadius;\n        b.forEach(function (d, b) {\n          a.options.splitSeries && !d.isParentNode ? (e = d.series.parentNode.plotX, f = d.series.parentNode.plotY) : (e = g.width / 2, f = g.height / 2);\n          d.plotX = d.prevX = y(d.plotX, e + h * Math.cos(d.index || b * c));\n          d.plotY = d.prevY = y(d.plotY, f + h * Math.sin(d.index || b * c));\n          d.dispX = 0;\n          d.dispY = 0;\n        });\n      },\n      repulsiveForces: function repulsiveForces() {\n        var a = this,\n            g,\n            b,\n            c,\n            e = a.options.bubblePadding;\n        a.nodes.forEach(function (d) {\n          d.degree = d.mass;\n          d.neighbours = 0;\n          a.nodes.forEach(function (k) {\n            g = 0;\n            d === k || d.fixedPosition || !a.options.seriesInteraction && d.series !== k.series || (c = a.getDistXY(d, k), b = a.vectorLength(c) - (d.marker.radius + k.marker.radius + e), 0 > b && (d.degree += .01, d.neighbours++, g = a.repulsiveForce(-b / Math.sqrt(d.neighbours), a.k, d, k)), a.force(\"repulsive\", d, g * k.mass, c, k, b));\n          });\n        });\n      },\n      applyLimitBox: function applyLimitBox(a) {\n        if (this.options.splitSeries && !a.isParentNode && this.options.parentNodeLimit) {\n          var d = this.getDistXY(a, a.series.parentNode);\n          var b = a.series.parentNodeRadius - a.marker.radius - this.vectorLength(d);\n          0 > b && b > -2 * a.marker.radius && (a.plotX -= .01 * d.x, a.plotY -= .01 * d.y);\n        }\n\n        m.prototype.applyLimitBox.apply(this, arguments);\n      }\n    });\n    h(\"packedbubble\", \"bubble\", {\n      minSize: \"10%\",\n      maxSize: \"50%\",\n      sizeBy: \"area\",\n      zoneAxis: \"y\",\n      crisp: !1,\n      tooltip: {\n        pointFormat: \"Value: {point.value}\"\n      },\n      draggable: !0,\n      useSimulation: !0,\n      parentNode: {\n        allowPointSelect: !1\n      },\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        parentNodeFormatter: function parentNodeFormatter() {\n          return this.name;\n        },\n        parentNodeTextPath: {\n          enabled: !0\n        },\n        padding: 0,\n        style: {\n          transition: \"opacity 2000ms\"\n        }\n      },\n      layoutAlgorithm: {\n        initialPositions: \"circle\",\n        initialPositionRadius: 20,\n        bubblePadding: 5,\n        parentNodeLimit: !1,\n        seriesInteraction: !0,\n        dragBetweenSeries: !1,\n        parentNodeOptions: {\n          maxIterations: 400,\n          gravitationalConstant: .03,\n          maxSpeed: 50,\n          initialPositionRadius: 100,\n          seriesInteraction: !0,\n          marker: {\n            fillColor: null,\n            fillOpacity: 1,\n            lineWidth: 1,\n            lineColor: null,\n            symbol: \"circle\"\n          }\n        },\n        enableSimulation: !0,\n        type: \"packedbubble\",\n        integration: \"packedbubble\",\n        maxIterations: 1E3,\n        splitSeries: !1,\n        maxSpeed: 5,\n        gravitationalConstant: .01,\n        friction: -.981\n      }\n    }, {\n      hasDraggableNodes: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      pointArrayMap: [\"value\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"],\n      pointValKey: \"value\",\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      axisTypes: [],\n      noSharedTooltip: !0,\n      searchPoint: b.noop,\n      accumulateAllPoints: function accumulateAllPoints(a) {\n        var d = a.chart,\n            b = [],\n            c,\n            e;\n\n        for (c = 0; c < d.series.length; c++) {\n          if (a = d.series[c], a.is(\"packedbubble\") && a.visible || !d.options.chart.ignoreHiddenSeries) for (e = 0; e < a.yData.length; e++) {\n            b.push([null, null, a.yData[e], a.index, e, {\n              id: e,\n              marker: {\n                radius: 0\n              }\n            }]);\n          }\n        }\n\n        return b;\n      },\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        t(this, \"updatedData\", function () {\n          this.chart.series.forEach(function (a) {\n            a.type === this.type && (a.isDirty = !0);\n          }, this);\n        });\n        return this;\n      },\n      render: function render() {\n        var a = [];\n        v.prototype.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (d) {\n          l(d.dataLabels) && d.dataLabels.forEach(function (d) {\n            a.push(d);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      },\n      setVisible: function setVisible() {\n        var a = this;\n        v.prototype.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (d) {\n          a.layout.removeElementFromCollection(d, a.layout.nodes);\n        }));\n      },\n      drawDataLabels: function drawDataLabels() {\n        var a = this.options.dataLabels.textPath,\n            b = this.points;\n        v.prototype.drawDataLabels.apply(this, arguments);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, v.prototype.drawDataLabels.apply(this, arguments), this.points = b, this.options.dataLabels.textPath = a);\n      },\n      seriesBox: function seriesBox() {\n        var a = this.chart,\n            b = Math.max,\n            c = Math.min,\n            e,\n            f = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight];\n        this.data.forEach(function (a) {\n          B(a.plotX) && B(a.plotY) && a.marker.radius && (e = a.marker.radius, f[0] = c(f[0], a.plotX - e), f[1] = b(f[1], a.plotX + e), f[2] = c(f[2], a.plotY - e), f[3] = b(f[3], a.plotY + e));\n        });\n        return w(f.width / f.height) ? f : null;\n      },\n      calculateParentRadius: function calculateParentRadius() {\n        var a = this.seriesBox();\n        this.parentNodeRadius = x(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      },\n      drawGraph: function drawGraph() {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart,\n              b = this.layout.options.parentNodeOptions.marker;\n          b = {\n            fill: b.fillColor || q(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": b.lineWidth\n          };\n          var c = this.visible ? \"inherit\" : \"hidden\";\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", c, .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          c = p({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, b);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(b.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(c);\n        }\n      },\n      createParentNodes: function createParentNodes() {\n        var a = this,\n            b = a.chart,\n            c = a.parentNodeLayout,\n            e,\n            f = a.parentNode,\n            h = a.pointClass;\n        a.parentNodeMass = 0;\n        a.points.forEach(function (d) {\n          a.parentNodeMass += Math.PI * Math.pow(d.marker.radius, 2);\n        });\n        a.calculateParentRadius();\n        c.nodes.forEach(function (d) {\n          d.seriesIndex === a.index && (e = !0);\n        });\n        c.setArea(0, 0, b.plotWidth, b.plotHeight);\n        e || (f || (f = new h().init(this, {\n          mass: a.parentNodeRadius / 2,\n          marker: {\n            radius: a.parentNodeRadius\n          },\n          dataLabels: {\n            inside: !1\n          },\n          dataLabelOnNull: !0,\n          degree: a.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: a.index\n        })), a.parentNode && (f.plotX = a.parentNode.plotX, f.plotY = a.parentNode.plotY), a.parentNode = f, c.addElementsToCollection([a], c.series), c.addElementsToCollection([f], c.nodes));\n      },\n      drawTracker: function drawTracker() {\n        var a = this.parentNode;\n        b.TrackerMixin.drawTrackerPoint.call(this);\n\n        if (a) {\n          var g = l(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          g.forEach(function (d) {\n            d.div ? d.div.point = a : d.element.point = a;\n          });\n        }\n      },\n      addSeriesLayout: function addSeriesLayout() {\n        var a = this.options.layoutAlgorithm,\n            g = this.chart.graphLayoutsStorage,\n            c = this.chart.graphLayoutsLookup,\n            e = p(a, a.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var f = g[a.type + \"-series\"];\n        f || (g[a.type + \"-series\"] = f = new b.layouts[a.type](), f.init(e), c.splice(f.index, 0, f));\n        this.parentNodeLayout = f;\n        this.createParentNodes();\n      },\n      addLayout: function addLayout() {\n        var a = this.options.layoutAlgorithm,\n            g = this.chart.graphLayoutsStorage,\n            c = this.chart.graphLayoutsLookup,\n            e = this.chart.options.chart;\n        g || (this.chart.graphLayoutsStorage = g = {}, this.chart.graphLayoutsLookup = c = []);\n        var f = g[a.type];\n        f || (a.enableSimulation = B(e.forExport) ? !e.forExport : a.enableSimulation, g[a.type] = f = new b.layouts[a.type](), f.init(a), c.splice(f.index, 0, f));\n        this.layout = f;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        f.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        f.addElementsToCollection([this], f.series);\n        f.addElementsToCollection(this.points, f.nodes);\n      },\n      deferLayout: function deferLayout() {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      },\n      translate: function translate() {\n        var a = this.chart,\n            b = this.data,\n            k = this.index,\n            e,\n            f = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        B(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(this), this.getPointRadius());\n        if (f) var h = a.allDataPoints;else h = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (e = 0; e < h.length; e++) {\n          if (h[e][3] === k) {\n            var l = b[h[e][4]];\n            var m = h[e][2];\n            f || (l.plotX = h[e][0] - a.plotLeft + a.diffX, l.plotY = h[e][1] - a.plotTop + a.diffY);\n            l.marker = z(l.marker, {\n              radius: m,\n              width: 2 * m,\n              height: 2 * m\n            });\n            l.radius = m;\n          }\n        }\n\n        f && this.deferLayout();\n        c(this, \"afterTranslate\");\n      },\n      checkOverlap: function checkOverlap(a, b) {\n        var d = a[0] - b[0],\n            g = a[1] - b[1];\n        return -.001 > Math.sqrt(d * d + g * g) - Math.abs(a[2] + b[2]);\n      },\n      positionBubble: function positionBubble(a, b, c) {\n        var d = Math.sqrt,\n            g = Math.asin,\n            k = Math.acos,\n            e = Math.pow,\n            f = Math.abs;\n        d = d(e(a[0] - b[0], 2) + e(a[1] - b[1], 2));\n        k = k((e(d, 2) + e(c[2] + b[2], 2) - e(c[2] + a[2], 2)) / (2 * (c[2] + b[2]) * d));\n        g = g(f(a[0] - b[0]) / d);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + k + g * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + c[2]) * Math.sin(a), b[1] - (b[2] + c[2]) * Math.cos(a), c[2], c[3], c[4]];\n      },\n      placeBubbles: function placeBubbles(a) {\n        var b = this.checkOverlap,\n            d = this.positionBubble,\n            c = [],\n            e = 1,\n            f = 0,\n            h = 0;\n        var l = [];\n        var m;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          c.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (c.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), m = 2; m < a.length; m++) {\n            a[m][2] = a[m][2] || 1, l = d(c[e][f], c[e - 1][h], a[m]), b(l, c[e][0]) ? (c.push([]), h = 0, c[e + 1].push(d(c[e][f], c[e][0], a[m])), e++, f = 0) : 1 < e && c[e - 1][h + 1] && b(l, c[e - 1][h + 1]) ? (h++, c[e].push(d(c[e][f], c[e - 1][h], a[m])), f++) : (f++, c[e].push(l));\n          }\n          this.chart.stages = c;\n          this.chart.rawPositions = [].concat.apply([], c);\n          this.resizeRadius();\n          l = this.chart.rawPositions;\n        }\n\n        return l;\n      },\n      resizeRadius: function resizeRadius() {\n        var a = this.chart,\n            b = a.rawPositions,\n            c = Math.min,\n            e = Math.max,\n            f = a.plotLeft,\n            h = a.plotTop,\n            l = a.plotHeight,\n            m = a.plotWidth,\n            n,\n            p,\n            q;\n        var t = n = Number.POSITIVE_INFINITY;\n        var v = p = Number.NEGATIVE_INFINITY;\n\n        for (q = 0; q < b.length; q++) {\n          var w = b[q][2];\n          t = c(t, b[q][0] - w);\n          v = e(v, b[q][0] + w);\n          n = c(n, b[q][1] - w);\n          p = e(p, b[q][1] + w);\n        }\n\n        q = [v - t, p - n];\n        c = c.apply([], [(m - f) / q[0], (l - h) / q[1]]);\n\n        if (1e-10 < Math.abs(c - 1)) {\n          for (q = 0; q < b.length; q++) {\n            b[q][2] *= c;\n          }\n\n          this.placeBubbles(b);\n        } else a.diffY = l / 2 + h - n - (p - n) / 2, a.diffX = m / 2 + f - t - (v - t) / 2;\n      },\n      calculateZExtremes: function calculateZExtremes() {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            c = Infinity,\n            e = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            B(a) && (a > e && (e = a), a < c && (c = a));\n          });\n        });\n        a = y(a, c);\n        b = y(b, e);\n        return [a, b];\n      },\n      getPointRadius: function getPointRadius() {\n        var a = this,\n            b = a.chart,\n            c = a.options,\n            e = c.useSimulation,\n            f = Math.min(b.plotWidth, b.plotHeight),\n            h = {},\n            l = [],\n            m = b.allDataPoints,\n            n,\n            p,\n            q,\n            t;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              d = /%$/.test(c[a]);\n          h[a] = d ? f * b / 100 : b * Math.sqrt(m.length);\n        });\n        b.minRadius = n = h.minSize / Math.sqrt(m.length);\n        b.maxRadius = p = h.maxSize / Math.sqrt(m.length);\n        var v = e ? a.calculateZExtremes() : [n, p];\n        (m || []).forEach(function (b, c) {\n          q = e ? x(b[2], v[0], v[1]) : b[2];\n          t = a.getRadius(v[0], v[1], n, p, q);\n          0 === t && (t = null);\n          m[c][2] = t;\n          l.push(t);\n        });\n        a.radii = l;\n      },\n      redrawHalo: n.redrawHalo,\n      onMouseDown: n.onMouseDown,\n      onMouseMove: n.onMouseMove,\n      onMouseUp: function onMouseUp(a) {\n        if (a.fixedPosition && !a.removed) {\n          var b,\n              c,\n              d = this.layout,\n              e = this.parentNodeLayout;\n          e && d.options.dragBetweenSeries && e.nodes.forEach(function (g) {\n            a && a.marker && g !== a.series.parentNode && (b = d.getDistXY(a, g), c = d.vectorLength(b) - g.marker.radius - a.marker.radius, 0 > c && (g.series.addPoint(p(a.options, {\n              plotX: a.plotX,\n              plotY: a.plotY\n            }), !1), d.removeElementFromCollection(a, d.nodes), a.remove()));\n          });\n          n.onMouseUp.apply(this, arguments);\n        }\n      },\n      destroy: function destroy() {\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (a) {\n          a.removeElementFromCollection(this, a.series);\n        }, this);\n        this.parentNode && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        b.Series.prototype.destroy.apply(this, arguments);\n      },\n      alignDataLabel: b.Series.prototype.alignDataLabel\n    }, {\n      destroy: function destroy() {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return e.prototype.destroy.apply(this, arguments);\n      },\n      firePointEvent: function firePointEvent(a, b, c) {\n        var d = this.series.options;\n\n        if (this.isParentNode && d.parentNode) {\n          var g = d.allowPointSelect;\n          d.allowPointSelect = d.parentNode.allowPointSelect;\n          e.prototype.firePointEvent.apply(this, arguments);\n          d.allowPointSelect = g;\n        } else e.prototype.firePointEvent.apply(this, arguments);\n      },\n      select: function select(a, c) {\n        var d = this.series.chart;\n        this.isParentNode ? (d.getSelectedPoints = d.getSelectedParentNodes, e.prototype.select.apply(this, arguments), d.getSelectedPoints = b.Chart.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);\n      }\n    });\n    t(f, \"beforeRedraw\", function () {\n      this.allDataPoints && delete this.allDataPoints;\n    });\n    \"\";\n  });\n  C(f, \"parts-more/Polar.js\", [f[\"parts/Chart.js\"], f[\"parts/Globals.js\"], f[\"parts-more/Pane.js\"], f[\"parts/Pointer.js\"], f[\"parts/SVGRenderer.js\"], f[\"parts/Utilities.js\"]], function (f, a, b, e, h, q) {\n    var t = q.addEvent,\n        x = q.animObject,\n        B = q.defined,\n        z = q.find,\n        c = q.isNumber,\n        l = q.pick,\n        w = q.splat,\n        p = q.uniqueKey,\n        y = q.wrap,\n        v = a.Series,\n        m = a.seriesTypes,\n        n = v.prototype;\n    e = e.prototype;\n\n    n.searchPointByAngle = function (a) {\n      var b = this.chart,\n          c = this.xAxis.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop)\n      });\n    };\n\n    n.getConnectors = function (a, b, c, d) {\n      var g = d ? 1 : 0;\n      var e = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > e - 1 ? a.length - (1 + g) : e - 1;\n      g = e + 1 > a.length - 1 ? g : e + 1;\n      var f = a[b];\n      g = a[g];\n      var k = f.plotX;\n      f = f.plotY;\n      var h = g.plotX;\n      var l = g.plotY;\n      g = a[e].plotX;\n      e = a[e].plotY;\n      k = (1.5 * g + k) / 2.5;\n      f = (1.5 * e + f) / 2.5;\n      h = (1.5 * g + h) / 2.5;\n      var m = (1.5 * e + l) / 2.5;\n      l = Math.sqrt(Math.pow(k - g, 2) + Math.pow(f - e, 2));\n      var n = Math.sqrt(Math.pow(h - g, 2) + Math.pow(m - e, 2));\n      k = Math.atan2(f - e, k - g);\n      m = Math.PI / 2 + (k + Math.atan2(m - e, h - g)) / 2;\n      Math.abs(k - m) > Math.PI / 2 && (m -= Math.PI);\n      k = g + Math.cos(m) * l;\n      f = e + Math.sin(m) * l;\n      h = g + Math.cos(Math.PI + m) * n;\n      m = e + Math.sin(Math.PI + m) * n;\n      g = {\n        rightContX: h,\n        rightContY: m,\n        leftContX: k,\n        leftContY: f,\n        plotX: g,\n        plotY: e\n      };\n      c && (g.prevPointCont = this.getConnectors(a, b, !1, d));\n      return g;\n    };\n\n    n.toXY = function (a) {\n      var b = this.chart,\n          c = this.xAxis;\n      var d = this.yAxis;\n      var e = a.plotX,\n          g = a.plotY,\n          f = a.series,\n          h = b.inverted,\n          l = a.y,\n          m = h ? e : d.len - g;\n      h && f && !f.isRadialBar && (a.plotY = g = \"number\" === typeof l ? d.translate(l) || 0 : 0);\n      a.rectPlotX = e;\n      a.rectPlotY = g;\n      d.center && (m += d.center[3] / 2);\n      d = h ? d.postTranslate(g, m) : c.postTranslate(e, m);\n      a.plotX = a.polarPlotX = d.x - b.plotLeft;\n      a.plotY = a.polarPlotY = d.y - b.plotTop;\n      this.kdByAngle ? (b = (e / Math.PI * 180 + c.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n    };\n\n    m.spline && (y(m.spline.prototype, \"getPointSpline\", function (a, b, c, d) {\n      this.chart.polar ? d ? (a = this.getConnectors(b, d, !0, this.connectEnds), a = [\"C\", a.prevPointCont.rightContX, a.prevPointCont.rightContY, a.leftContX, a.leftContY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, d);\n      return a;\n    }), m.areasplinerange && (m.areasplinerange.prototype.getPointSpline = m.spline.prototype.getPointSpline));\n    t(v, \"afterTranslate\", function () {\n      var b = this.chart;\n\n      if (b.polar && this.xAxis) {\n        (this.kdByAngle = b.tooltip && b.tooltip.shared) ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = \"xy\";\n        if (!this.preventPostTranslate) for (var c = this.points, d = c.length; d--;) {\n          this.toXY(c[d]), !b.hasParallelCoordinates && !this.yAxis.reversed && c[d].y < this.yAxis.min && (c[d].isNull = !0);\n        }\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(t(this, \"afterRender\", function () {\n          if (b.polar) {\n            var c = this.yAxis.pane.center;\n            this.clipCircle ? this.clipCircle.animate({\n              x: c[0],\n              y: c[1],\n              r: c[2] / 2,\n              innerR: c[3] / 2\n            }) : this.clipCircle = b.renderer.clipCircle(c[0], c[1], c[2] / 2, c[3] / 2);\n            this.group.clip(this.clipCircle);\n            this.setClip = a.noop;\n          }\n        })));\n      }\n    }, {\n      order: 2\n    });\n    y(n, \"getGraphPath\", function (a, b) {\n      var c = this,\n          d;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (d = 0; d < b.length; d++) {\n          if (!b[d].isNull) {\n            var e = d;\n            break;\n          }\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var g = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.toXY(a);\n        });\n      }\n\n      d = a.apply(this, [].slice.call(arguments, 1));\n      g && b.pop();\n      return d;\n    });\n\n    var d = function d(b, c) {\n      var d = this,\n          e = this.chart,\n          f = this.options.animation,\n          g = this.group,\n          k = this.markerGroup,\n          h = this.xAxis.center,\n          m = e.plotLeft,\n          n = e.plotTop,\n          p,\n          q,\n          t,\n          v;\n      if (e.polar) {\n        if (d.isRadialBar) c || (d.startAngleRad = l(d.translatedThreshold, d.xAxis.startAngleRad), a.seriesTypes.pie.prototype.animate.call(d, c));else {\n          if (e.renderer.isSVG) if (f = x(f), d.is(\"column\")) {\n            if (!c) {\n              var w = h[3] / 2;\n              d.points.forEach(function (a) {\n                p = a.graphic;\n                t = (q = a.shapeArgs) && q.r;\n                v = q && q.innerR;\n                p && q && (p.attr({\n                  r: w,\n                  innerR: w\n                }), p.animate({\n                  r: t,\n                  innerR: v\n                }, d.options.animation));\n              });\n            }\n          } else c ? (b = {\n            translateX: h[0] + m,\n            translateY: h[1] + n,\n            scaleX: .001,\n            scaleY: .001\n          }, g.attr(b), k && k.attr(b)) : (b = {\n            translateX: m,\n            translateY: n,\n            scaleX: 1,\n            scaleY: 1\n          }, g.animate(b, f), k && k.animate(b, f));\n        }\n      } else b.call(this, c);\n    };\n\n    y(n, \"animate\", d);\n    m.column && (v = m.arearange.prototype, m = m.column.prototype, m.polarArc = function (a, b, c, d) {\n      var e = this.xAxis.center,\n          f = this.yAxis.len,\n          g = e[3] / 2;\n      b = f - b + g;\n      a = f - l(a, f) + g;\n      this.yAxis.reversed && (0 > b && (b = g), 0 > a && (a = g));\n      return {\n        x: e[0],\n        y: e[1],\n        r: b,\n        innerR: a,\n        start: c,\n        end: d\n      };\n    }, y(m, \"animate\", d), y(m, \"translate\", function (a) {\n      var b = this.options,\n          d = b.stacking,\n          e = this.chart,\n          f = this.xAxis,\n          g = this.yAxis,\n          h = g.reversed,\n          l = g.center,\n          m = f.startAngleRad,\n          n = f.endAngleRad - m;\n      this.preventPostTranslate = !0;\n      a.call(this);\n\n      if (f.isRadial) {\n        a = this.points;\n        f = a.length;\n        var p = g.translate(g.min);\n        var t = g.translate(g.max);\n        b = b.threshold || 0;\n\n        if (e.inverted && c(b)) {\n          var v = g.translate(b);\n          B(v) && (0 > v ? v = 0 : v > n && (v = n), this.translatedThreshold = v + m);\n        }\n\n        for (; f--;) {\n          b = a[f];\n          var w = b.barX;\n          var z = b.x;\n          var y = b.y;\n          b.shapeType = \"arc\";\n\n          if (e.inverted) {\n            b.plotY = g.translate(y);\n\n            if (d && g.stacking) {\n              if (y = g.stacking.stacks[(0 > y ? \"-\" : \"\") + this.stackKey], this.visible && y && y[z] && !b.isNull) {\n                var x = y[z].points[this.getStackIndicator(void 0, z, this.index).key];\n                var C = g.translate(x[0]);\n                x = g.translate(x[1]);\n                B(C) && (C = q.clamp(C, 0, n));\n              }\n            } else C = v, x = b.plotY;\n\n            C > x && (x = [C, C = x][0]);\n            if (!h) {\n              if (C < p) C = p;else if (x > t) x = t;else {\n                if (x < p || C > t) C = x = 0;\n              }\n            } else if (x > p) x = p;else if (C < t) C = t;else if (C > p || x < t) C = x = n;\n            g.min > g.max && (C = x = h ? n : 0);\n            C += m;\n            x += m;\n            l && (b.barX = w += l[3] / 2);\n            z = Math.max(w, 0);\n            y = Math.max(w + b.pointWidth, 0);\n            b.shapeArgs = {\n              x: l && l[0],\n              y: l && l[1],\n              r: y,\n              innerR: z,\n              start: C,\n              end: x\n            };\n            b.opacity = C === x ? 0 : void 0;\n            b.plotY = (B(this.translatedThreshold) && (C < this.translatedThreshold ? C : x)) - m;\n          } else C = w + m, b.shapeArgs = this.polarArc(b.yBottom, b.plotY, C, C + b.pointWidth);\n\n          this.toXY(b);\n          e.inverted ? (w = g.postTranslate(b.rectPlotY, w + b.pointWidth / 2), b.tooltipPos = [w.x - e.plotLeft, w.y - e.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n          l && (b.ttBelow = b.plotY > l[1]);\n        }\n      }\n    }), m.findAlignments = function (a, b) {\n      null === b.align && (b.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\");\n      null === b.verticalAlign && (b.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\");\n      return b;\n    }, v && (v.findAlignments = m.findAlignments), y(m, \"alignDataLabel\", function (a, b, c, d, e, f) {\n      var g = this.chart,\n          h = l(d.inside, !!this.options.stacking);\n      g.polar ? (a = b.rectPlotX / Math.PI * 180, g.inverted ? (this.forceDL = g.isInsidePlot(b.plotX, Math.round(b.plotY), !1), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate((e.start + e.end) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {\n        x: e.x - g.plotLeft,\n        y: e.y - g.plotTop\n      }) : b.tooltipPos && (e = {\n        x: b.tooltipPos[0],\n        y: b.tooltipPos[1]\n      }), d.align = l(d.align, \"center\"), d.verticalAlign = l(d.verticalAlign, \"middle\")) : this.findAlignments && (d = this.findAlignments(a, d)), n.alignDataLabel.call(this, b, c, d, e, f), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end && c.hide(!0)) : a.call(this, b, c, d, e, f);\n    }));\n    y(e, \"getCoordinates\", function (a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        var e = a.isXAxis,\n            f = a.center;\n\n        if (\"colorAxis\" !== a.coll) {\n          var g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    });\n\n    h.prototype.clipCircle = function (a, b, c, d) {\n      var e = p(),\n          f = this.createElement(\"clipPath\").attr({\n        id: e\n      }).add(this.defs);\n      a = d ? this.arc(a, b, c, d, 0, 2 * Math.PI).add(f) : this.circle(a, b, c).add(f);\n      a.id = e;\n      a.clipPath = f;\n      return a;\n    };\n\n    t(f, \"getAxes\", function () {\n      this.pane || (this.pane = []);\n      w(this.options.pane).forEach(function (a) {\n        new b(a, this);\n      }, this);\n    });\n    t(f, \"afterDrawChartBox\", function () {\n      this.pane.forEach(function (a) {\n        a.render();\n      });\n    });\n    t(a.Series, \"afterInit\", function () {\n      var a = this.chart;\n      a.inverted && a.polar && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0));\n    });\n    y(f.prototype, \"get\", function (a, b) {\n      return z(this.pane, function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    });\n  });\n  C(f, \"masters/highcharts-more.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}