{"ast":null,"code":"/*global describe*/\n\n/*global require*/\n\n/*global module*/\n\n/*global it*/\n\n/*global console*/\n\n/*global process*/\n\n/*global setTimeout*/\n\n/*global self*/\n//-------------------------------------------------------------------\n// SimplexJS\n// https://github.com/\n// An Object-Oriented Linear Programming Solver\n//\n// By Justin Wolcott (c)\n// Licensed under the MIT License.\n//-------------------------------------------------------------------\nvar Tableau = require(\"./Tableau/index.js\");\n\nvar Model = require(\"./Model\");\n\nvar branchAndCut = require(\"./Tableau/branchAndCut\");\n\nvar expressions = require(\"./expressions.js\");\n\nvar validation = require(\"./Validation\");\n\nvar Constraint = expressions.Constraint;\nvar Variable = expressions.Variable;\nvar Numeral = expressions.Numeral;\nvar Term = expressions.Term;\n\nvar External = require(\"./External/main.js\"); // Place everything under the Solver Name Space\n\n\nvar Solver = function Solver() {\n  \"use strict\";\n\n  this.Model = Model;\n  this.branchAndCut = branchAndCut;\n  this.Constraint = Constraint;\n  this.Variable = Variable;\n  this.Numeral = Numeral;\n  this.Term = Term;\n  this.Tableau = Tableau;\n  this.lastSolvedModel = null;\n  this.External = External;\n  /*************************************************************\r\n   * Method: Solve\r\n   * Scope: Public:\r\n   * Agruments:\r\n   *        model: The model we want solver to operate on\r\n   *        precision: If we're solving a MILP, how tight\r\n   *                   do we want to define an integer, given\r\n   *                   that 20.000000000000001 is not an integer.\r\n   *                   (defaults to 1e-9)\r\n   *            full: *get better description*\r\n   *        validate: if left blank, it will get ignored; otherwise\r\n   *                  it will run the model through all validation\r\n   *                  functions in the *Validate* module\r\n   **************************************************************/\n\n  this.Solve = function (model, precision, full, validate) {\n    //\n    // Run our validations on the model\n    // if the model doesn't have a validate\n    // attribute set to false\n    //\n    if (validate) {\n      for (var test in validation) {\n        model = validation[test](model);\n      }\n    } // Make sure we at least have a model\n\n\n    if (!model) {\n      throw new Error(\"Solver requires a model to operate on\");\n    } //\n    // If the objective function contains multiple objectives,\n    // pass it to the multi-solver thing...\n    //\n\n\n    if (typeof model.optimize === \"object\") {\n      if (Object.keys(model.optimize > 1)) {\n        return require(\"./Polyopt\")(this, model);\n      }\n    } // /////////////////////////////////////////////////////////////////////\n    // *********************************************************************\n    // START\n    // Try our hand at handling external solvers...\n    // START\n    // *********************************************************************\n    // /////////////////////////////////////////////////////////////////////\n\n\n    if (model.external) {\n      var solvers = Object.keys(External);\n      solvers = JSON.stringify(solvers); //\n      // The model needs to have a \"solver\" attribute if nothing else\n      // for us to pass data into\n      //\n\n      if (!model.external.solver) {\n        throw new Error(\"The model you provided has an 'external' object that doesn't have a solver attribute. Use one of the following:\" + solvers);\n      } //\n      // If the solver they request doesn't exist; provide them\n      // with a list of possible options:\n      //\n\n\n      if (!External[model.external.solver]) {\n        throw new Error(\"No support (yet) for \" + model.external.solver + \". Please use one of these instead:\" + solvers);\n      }\n\n      return External[model.external.solver].solve(model); // /////////////////////////////////////////////////////////////////////\n      // *********************************************************************\n      //  END\n      // Try our hand at handling external solvers...\n      //  END\n      // *********************************************************************\n      // /////////////////////////////////////////////////////////////////////\n    } else {\n      if (model instanceof Model === false) {\n        model = new Model(precision).loadJson(model);\n      }\n\n      var solution = model.solve();\n      this.lastSolvedModel = model;\n      solution.solutionSet = solution.generateSolutionSet(); // If the user asks for a full breakdown\n      // of the tableau (e.g. full === true)\n      // this will return it\n\n      if (full) {\n        return solution;\n      } else {\n        // Otherwise; give the user the bare\n        // minimum of info necessary to carry on\n        var store = {}; // 1.) Add in feasibility to store;\n\n        store.feasible = solution.feasible; // 2.) Add in the objective value\n\n        store.result = solution.evaluation;\n        store.bounded = solution.bounded;\n\n        if (solution._tableau.__isIntegral) {\n          store.isIntegral = true;\n        } // 3.) Load all of the variable values\n\n\n        Object.keys(solution.solutionSet).forEach(function (d) {\n          //\n          // When returning data in standard format,\n          // Remove all 0's\n          //\n          if (solution.solutionSet[d] !== 0) {\n            store[d] = solution.solutionSet[d];\n          }\n        });\n        return store;\n      }\n    }\n  };\n  /*************************************************************\r\n   * Method: ReformatLP\r\n   * Scope: Public:\r\n   * Agruments: model: The model we want solver to operate on\r\n   * Purpose: Convert a friendly JSON model into a model for a\r\n   *          real solving library...in this case\r\n   *          lp_solver\r\n   **************************************************************/\n\n\n  this.ReformatLP = require(\"./External/lpsolve/Reformat.js\");\n  /*************************************************************\r\n  * Method: MultiObjective\r\n  * Scope: Public:\r\n  * Agruments:\r\n  *        model: The model we want solver to operate on\r\n  *        detail: if false, or undefined; it will return the\r\n  *                result of using the mid-point formula; otherwise\r\n  *                it will return an object containing:\r\n  *\r\n  *                1. The results from the mid point formula\r\n  *                2. The solution for each objective solved\r\n  *                   in isolation (pareto)\r\n  *                3. The min and max of each variable along\r\n  *                   the frontier of the polytope (ranges)\r\n  * Purpose: Solve a model with multiple objective functions.\r\n  *          Since a potential infinite number of solutions exist\r\n  *          this naively returns the mid-point between\r\n  *\r\n  * Note: The model has to be changed a little to work with this.\r\n  *       Before an *opType* was required. No more. The objective\r\n  *       attribute of the model is now an object instead of a\r\n  *       string.\r\n  *\r\n  *  *EXAMPLE MODEL*\r\n  *\r\n  *   model = {\r\n  *       optimize: {scotch: \"max\", soda: \"max\"},\r\n  *       constraints: {fluid: {equal: 100}},\r\n  *       variables: {\r\n  *           scotch: {fluid: 1, scotch: 1},\r\n  *           soda: {fluid: 1, soda: 1}\r\n  *       }\r\n  *   }\r\n  *\r\n  **************************************************************/\n\n  this.MultiObjective = function (model) {\n    return require(\"./Polyopt\")(this, model);\n  };\n}; // var define = define || undefined;\n// var window = window || undefined;\n// If the project is loading through require.js, use `define` and exit\n\n\nif (typeof define === \"function\") {\n  define([], function () {\n    return new Solver();\n  }); // If the project doesn't see define, but sees window, put solver on window\n} else if (typeof window === \"object\") {\n  window.solver = new Solver();\n} else if (typeof self === \"object\") {\n  self.solver = new Solver();\n} // Ensure that its available in node.js env\n\n\nmodule.exports = new Solver();","map":null,"metadata":{},"sourceType":"script"}